<script type="text/babel">
    const OnboardingTutorial = ({ steps, isAdmin, onComplete, onSkip }) => {
        const { useState, useEffect, useRef } = React;
        const [currentStepIndex, setCurrentStepIndex] = useState(0);
        const [isActive, setIsActive] = useState(true);
        const [targetElement, setTargetElement] = useState(null);
        const [tooltipPosition, setTooltipPosition] = useState({ top: 0, left: 0 });
        const [highlightPosition, setHighlightPosition] = useState({ top: 0, left: 0, width: 0, height: 0 });
        const [isTargetVisible, setIsTargetVisible] = useState(false);
        const modalRef = useRef(null);
        const previouslyFocusedElement = useRef(null);
        const tooltipRef = useRef(null);
        const autoAdvanceTimeoutRef = useRef(null);

        // Filter steps based on adminOnly flag
        const filteredSteps = React.useMemo(() => {
            if (!steps || !Array.isArray(steps)) return [];
            return steps.filter(step => !step.adminOnly || isAdmin);
        }, [steps, isAdmin]);

        // Deactivate tutorial when there are no usable steps (runs before keyboard handlers)
        useEffect(() => {
            if (filteredSteps.length === 0 && isActive) {
                setIsActive(false);
                // Call onComplete when no steps available (tutorial effectively completed)
                if (onComplete) onComplete();
            }
        }, [filteredSteps.length, isActive, onComplete]);

        // Helper function to safely query selector
        const getTargetElement = (selector) => {
            if (!selector) return null;
            try {
                return document.querySelector(selector);
            } catch (error) {
                console.warn('[OnboardingTutorial] Invalid selector:', selector, error);
                return null;
            }
        };

        // Check if element is in viewport
        const isElementInViewport = (element) => {
            if (!element) return false;
            const rect = element.getBoundingClientRect();
            return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        };

        // Smooth scroll element into view
        const scrollToElement = (element) => {
            if (!element) return;
            element.scrollIntoView({ behavior: 'smooth', block: 'center' });
        };

        // Get all focusable elements within container
        const getFocusableElements = (container) => {
            if (!container) return [];
            const selector = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
            return Array.from(container.querySelectorAll(selector)).filter(el => {
                return !el.disabled && el.offsetWidth > 0 && el.offsetHeight > 0;
            });
        };

        // Calculate tooltip position based on target and placement
        const calculateTooltipPosition = (targetRect, placement, tooltipWidth, tooltipHeight) => {
            const gap = 16;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            let top = 0;
            let left = 0;

            switch (placement) {
                case 'bottom':
                    top = targetRect.bottom + gap;
                    left = targetRect.left + (targetRect.width / 2) - (tooltipWidth / 2);
                    // Check if tooltip would overflow bottom
                    if (top + tooltipHeight > viewportHeight) {
                        // Flip to top
                        top = targetRect.top - tooltipHeight - gap;
                    }
                    // Check if tooltip would overflow left
                    if (left < 0) {
                        left = gap;
                    }
                    // Check if tooltip would overflow right
                    if (left + tooltipWidth > viewportWidth) {
                        left = viewportWidth - tooltipWidth - gap;
                    }
                    break;
                case 'top':
                    top = targetRect.top - tooltipHeight - gap;
                    left = targetRect.left + (targetRect.width / 2) - (tooltipWidth / 2);
                    // Check if tooltip would overflow top
                    if (top < 0) {
                        // Flip to bottom
                        top = targetRect.bottom + gap;
                    }
                    // Check if tooltip would overflow left
                    if (left < 0) {
                        left = gap;
                    }
                    // Check if tooltip would overflow right
                    if (left + tooltipWidth > viewportWidth) {
                        left = viewportWidth - tooltipWidth - gap;
                    }
                    break;
                case 'left':
                    top = targetRect.top + (targetRect.height / 2) - (tooltipHeight / 2);
                    left = targetRect.left - tooltipWidth - gap;
                    // Check if tooltip would overflow left
                    if (left < 0) {
                        // Flip to right
                        left = targetRect.right + gap;
                    }
                    // Check if tooltip would overflow top
                    if (top < 0) {
                        top = gap;
                    }
                    // Check if tooltip would overflow bottom
                    if (top + tooltipHeight > viewportHeight) {
                        top = viewportHeight - tooltipHeight - gap;
                    }
                    break;
                case 'right':
                    top = targetRect.top + (targetRect.height / 2) - (tooltipHeight / 2);
                    left = targetRect.right + gap;
                    // Check if tooltip would overflow right
                    if (left + tooltipWidth > viewportWidth) {
                        // Flip to left
                        left = targetRect.left - tooltipWidth - gap;
                    }
                    // Check if tooltip would overflow top
                    if (top < 0) {
                        top = gap;
                    }
                    // Check if tooltip would overflow bottom
                    if (top + tooltipHeight > viewportHeight) {
                        top = viewportHeight - tooltipHeight - gap;
                    }
                    break;
                default:
                    // Default to bottom
                    top = targetRect.bottom + gap;
                    left = targetRect.left + (targetRect.width / 2) - (tooltipWidth / 2);
            }

            return { top, left };
        };

        // Update target element and positions
        const updateTargetElement = () => {
            // Clear any existing auto-advance timeout
            if (autoAdvanceTimeoutRef.current) {
                clearTimeout(autoAdvanceTimeoutRef.current);
                autoAdvanceTimeoutRef.current = null;
            }

            if (currentStepIndex >= filteredSteps.length) {
                setIsActive(false);
                return;
            }

            const currentStep = filteredSteps[currentStepIndex];
            if (!currentStep) {
                setIsActive(false);
                return;
            }

            const element = getTargetElement(currentStep.selector);
            
            if (!element) {
                console.warn('[OnboardingTutorial] Target element not found for step:', currentStep.id, currentStep.selector);
                // Auto-advance to next step after delay
                autoAdvanceTimeoutRef.current = setTimeout(() => {
                    autoAdvanceTimeoutRef.current = null;
                    if (currentStepIndex < filteredSteps.length - 1) {
                        setCurrentStepIndex(prev => prev + 1);
                    } else {
                        // All steps completed or skipped
                        setIsActive(false);
                        if (onComplete) onComplete();
                    }
                }, 500);
                setIsTargetVisible(false);
                return;
            }

            setTargetElement(element);
            setIsTargetVisible(true);

            // Scroll element into view if not fully visible
            if (!isElementInViewport(element)) {
                scrollToElement(element);
            }

            // Wait for scroll to complete, then calculate positions
            setTimeout(() => {
                const rect = element.getBoundingClientRect();
                const highlightPadding = 8;
                
                // Calculate highlight position (with padding)
                setHighlightPosition({
                    top: rect.top - highlightPadding,
                    left: rect.left - highlightPadding,
                    width: rect.width + (highlightPadding * 2),
                    height: rect.height + (highlightPadding * 2)
                });

                // Calculate tooltip position
                const tooltipWidth = 520; // Default width, will be adjusted based on actual size
                const tooltipHeight = 300; // Estimated height
                const placement = currentStep.placement || 'bottom';
                
                // Get actual tooltip dimensions if available
                if (tooltipRef.current) {
                    const tooltipRect = tooltipRef.current.getBoundingClientRect();
                    const position = calculateTooltipPosition(rect, placement, tooltipRect.width, tooltipRect.height);
                    setTooltipPosition(position);
                } else {
                    // Use estimated dimensions
                    const position = calculateTooltipPosition(rect, placement, tooltipWidth, tooltipHeight);
                    setTooltipPosition(position);
                }
            }, 300);
        };

        // Update tooltip position when tooltip is rendered
        useEffect(() => {
            if (targetElement && tooltipRef.current) {
                const rect = targetElement.getBoundingClientRect();
                const tooltipRect = tooltipRef.current.getBoundingClientRect();
                const currentStep = filteredSteps[currentStepIndex];
                const placement = currentStep?.placement || 'bottom';
                const position = calculateTooltipPosition(rect, placement, tooltipRect.width, tooltipRect.height);
                setTooltipPosition(position);
            }
        }, [targetElement, currentStepIndex, filteredSteps]);

        // Initialize target element on mount and when step changes
        useEffect(() => {
            if (isActive && filteredSteps.length > 0) {
                updateTargetElement();
            }
        }, [currentStepIndex, isActive, filteredSteps.length]);

        // Cleanup auto-advance timeout on unmount or when step/index changes
        useEffect(() => {
            return () => {
                if (autoAdvanceTimeoutRef.current) {
                    clearTimeout(autoAdvanceTimeoutRef.current);
                    autoAdvanceTimeoutRef.current = null;
                }
            };
        }, [currentStepIndex, isActive]);

        // Store previously focused element on mount
        useEffect(() => {
            if (isActive) {
                previouslyFocusedElement.current = document.activeElement;
            }
        }, [isActive]);

        // Focus trap: trap Tab key navigation within modal
        useEffect(() => {
            if (!isActive || !modalRef.current) return;

            const handleTabKey = (e) => {
                if (e.key !== 'Tab') return;

                // Check if focus is inside the modal before cycling
                if (!modalRef.current.contains(document.activeElement)) {
                    return;
                }

                const focusableElements = getFocusableElements(modalRef.current);
                if (focusableElements.length === 0) return;

                const firstElement = focusableElements[0];
                const lastElement = focusableElements[focusableElements.length - 1];

                if (e.shiftKey) {
                    // Shift + Tab
                    if (document.activeElement === firstElement) {
                        e.preventDefault();
                        lastElement.focus();
                    }
                } else {
                    // Tab
                    if (document.activeElement === lastElement) {
                        e.preventDefault();
                        firstElement.focus();
                    }
                }
            };

            document.addEventListener('keydown', handleTabKey);
            return () => document.removeEventListener('keydown', handleTabKey);
        }, [isActive]);

        // Set focus to modal on mount
        useEffect(() => {
            if (isActive && modalRef.current) {
                const focusableElements = getFocusableElements(modalRef.current);
                if (focusableElements.length > 0) {
                    focusableElements[0].focus();
                } else {
                    modalRef.current.focus();
                }
            }
        }, [isActive, currentStepIndex]);

        // Keyboard navigation
        useEffect(() => {
            if (!isActive) return;

            const handleKeyDown = (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    if (onSkip) onSkip();
                    setIsActive(false);
                    if (previouslyFocusedElement.current) {
                        previouslyFocusedElement.current.focus();
                    }
                } else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    if (currentStepIndex > 0) {
                        setCurrentStepIndex(prev => prev - 1);
                    }
                } else if (e.key === 'ArrowRight' || e.key === 'Enter') {
                    e.preventDefault();
                    if (currentStepIndex < filteredSteps.length - 1) {
                        setCurrentStepIndex(prev => prev + 1);
                    } else {
                        // Last step
                        setIsActive(false);
                        if (onComplete) onComplete();
                        if (previouslyFocusedElement.current) {
                            previouslyFocusedElement.current.focus();
                        }
                    }
                }
            };

            document.addEventListener('keydown', handleKeyDown);
            return () => document.removeEventListener('keydown', handleKeyDown);
        }, [isActive, currentStepIndex, filteredSteps.length, onComplete, onSkip]);

        // Restore focus on unmount
        useEffect(() => {
            return () => {
                if (previouslyFocusedElement.current) {
                    previouslyFocusedElement.current.focus();
                }
            };
        }, []);

        if (!isActive || filteredSteps.length === 0) {
            return null;
        }

        const currentStep = filteredSteps[currentStepIndex];
        if (!currentStep) {
            return null;
        }

        const isFirstStep = currentStepIndex === 0;
        const isLastStep = currentStepIndex === filteredSteps.length - 1;

        return React.createElement("div", {
            className: "fixed inset-0 z-[60]",
            role: "dialog",
            "aria-modal": "true",
            "aria-labelledby": "tour-title",
            "aria-describedby": "tour-desc"
        },
            // Overlay
            React.createElement("div", {
                className: "fixed inset-0 bg-black bg-opacity-45 transition-opacity duration-300"
            }),
            
            // Highlight effect (spotlight)
            isTargetVisible && targetElement && React.createElement("div", {
                className: "onboarding-highlight",
                style: {
                    position: 'fixed',
                    top: `${highlightPosition.top}px`,
                    left: `${highlightPosition.left}px`,
                    width: `${highlightPosition.width}px`,
                    height: `${highlightPosition.height}px`,
                    pointerEvents: 'none',
                    zIndex: 61,
                    transition: 'all 0.3s ease-in-out',
                    borderRadius: '8px',
                    boxShadow: '0 0 0 6px rgba(59, 130, 246, 0.18), 0 0 20px rgba(59, 130, 246, 0.25)',
                    backgroundColor: 'transparent'
                }
            }),

            // Tooltip panel
            React.createElement("div", {
                ref: (el) => {
                    modalRef.current = el;
                    tooltipRef.current = el;
                },
                className: "onboarding-tooltip bg-white rounded-xl shadow-2xl p-6 border border-slate-200",
                style: {
                    position: 'fixed',
                    top: `${tooltipPosition.top}px`,
                    left: `${tooltipPosition.left}px`,
                    width: '520px',
                    maxWidth: '90vw',
                    zIndex: 62,
                    transition: 'all 0.3s ease-in-out'
                },
                tabIndex: -1
            },
                // Live region for screen readers
                React.createElement("div", {
                    "aria-live": "polite",
                    "aria-atomic": "true",
                    className: "sr-only"
                }, `Step ${currentStepIndex + 1} of ${filteredSteps.length}: ${currentStep.title}`),

                // Header
                React.createElement("div", { className: "mb-4" },
                    React.createElement("div", {
                        className: "text-xs text-slate-500 mb-1",
                        "aria-label": `Step ${currentStepIndex + 1} of ${filteredSteps.length}`
                    }, `Step ${currentStepIndex + 1} of ${filteredSteps.length}`),
                    React.createElement("h3", {
                        id: "tour-title",
                        className: "text-xl font-bold text-slate-800"
                    }, currentStep.title)
                ),

                // Body
                React.createElement("div", {
                    id: "tour-desc",
                    className: "mb-6 text-slate-600 leading-relaxed whitespace-pre-line"
                }, currentStep.body || (isTargetVisible ? null : "This feature is not currently visible. Moving to next step...")),

                // Footer buttons
                React.createElement("div", {
                    className: "flex justify-between items-center gap-3 flex-wrap"
                },
                    React.createElement("button", {
                        type: "button",
                        onClick: () => {
                            if (onSkip) onSkip();
                            setIsActive(false);
                            if (previouslyFocusedElement.current) {
                                previouslyFocusedElement.current.focus();
                            }
                        },
                        className: "px-4 py-2 bg-slate-200 hover:bg-slate-300 text-slate-700 rounded-md transition-colors",
                        "aria-label": "Skip tutorial"
                    }, "Skip All"),
                    React.createElement("div", { className: "flex gap-3" },
                        React.createElement("button", {
                            type: "button",
                            onClick: () => {
                                if (currentStepIndex > 0) {
                                    setCurrentStepIndex(prev => prev - 1);
                                }
                            },
                            disabled: isFirstStep,
                            className: "px-4 py-2 bg-slate-200 hover:bg-slate-300 text-slate-700 rounded-md transition-colors disabled:opacity-50 disabled:cursor-not-allowed",
                            "aria-label": "Go to previous step"
                        }, "Previous"),
                        React.createElement("button", {
                            type: "button",
                            onClick: () => {
                                if (currentStepIndex < filteredSteps.length - 1) {
                                    setCurrentStepIndex(prev => prev + 1);
                                } else {
                                    setIsActive(false);
                                    if (onComplete) onComplete();
                                    if (previouslyFocusedElement.current) {
                                        previouslyFocusedElement.current.focus();
                                    }
                                }
                            },
                            className: "px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md font-semibold transition-colors",
                            "aria-label": isLastStep ? "Finish tutorial" : "Go to next step"
                        }, isLastStep ? "Finish" : "Next")
                    )
                )
            )
        );
    };
</script>

<style>
    /* Screen reader only class */
    .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border-width: 0;
    }

    /* Onboarding tooltip animations */
    .onboarding-tooltip {
        animation: slideInTooltip 0.3s ease-out;
    }

    @keyframes slideInTooltip {
        from {
            opacity: 0;
            transform: translateY(-10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    /* Highlight pulse animation */
    .onboarding-highlight {
        animation: highlightPulse 2s ease-in-out infinite;
    }

    @keyframes highlightPulse {
        0%, 100% {
            box-shadow: 0 0 0 6px rgba(59, 130, 246, 0.18), 0 0 20px rgba(59, 130, 246, 0.25);
        }
        50% {
            box-shadow: 0 0 0 8px rgba(59, 130, 246, 0.25), 0 0 25px rgba(59, 130, 246, 0.35);
        }
    }

    /* Responsive adjustments */
    @media (max-width: 640px) {
        .onboarding-tooltip {
            width: 90vw !important;
            padding: 1rem !important;
        }

        .onboarding-tooltip .flex-wrap {
            flex-direction: column;
        }

        .onboarding-tooltip .flex-wrap > div {
            width: 100%;
        }

        .onboarding-tooltip button {
            width: 100%;
        }
    }
</style>

