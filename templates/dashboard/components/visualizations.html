<script type="text/babel">



    const Chatbot = ({ projectTasks, projectName }) => {
        const { useState, useEffect, useRef } = React;
        const [isOpen, setIsOpen] = useState(false);
        const [messages, setMessages] = useState([]);
        const [inputValue, setInputValue] = useState('');
        const [isLoading, setIsLoading] = useState(false);
        const [isTranslating, setIsTranslating] = useState(false);
        const [retryStatus, setRetryStatus] = useState(null);
        const messagesEndRef = useRef(null);
        const typingIntervalRef = useRef(null);
        const [currentLanguage, setCurrentLanguage] = useState('English');
        const [uiTranslations, setUiTranslations] = useState({
            header: 'PROTON AI',
            placeholder: 'Ask about the project...',
            suggestions: 'Suggestions',
            critical_activities_query: 'What are Critical Activities?',
            progress_query: 'Overall Project Progress',
            risk_query: 'Risk Assessment & Mitigation Ideas',
        });
        const LANGUAGES = {
            'English': 'en', 'Japanese': 'ja', 'French': 'fr', 'Spanish': 'es', 'Russian': 'ru', 'Mandarin': 'zh', 'Korean': 'ko', 'Kannada': 'kn', 'Hindi': 'hi', 'Gujarati': 'gu', 'Marathi': 'mr', 'Odia': 'or', 'Telugu': 'te', 'Malayalam': 'ml', 'Tamil': 'ta', 'Bengali': 'bn'
        };
        const englishDefaults = {
            header: 'PROTON AI',
            placeholder: 'Ask about the project...',
            suggestions: 'Suggestions',
            critical_activities_query: 'What are Critical Activities?',
            progress_query: 'Overall Project Progress',
            risk_query: 'Risk Assessment & Mitigation Ideas',
            greeting_template: `Hi, how can I help you with the "${projectName}" project today?'`
        };
        const predefinedQueryKeys = ["critical_activities_query", "progress_query", "risk_query"];
        const scrollToBottom = () => {
            messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
        };
        useEffect(scrollToBottom, [messages]);
        useEffect(() => {
            return () => {
                if (typingIntervalRef.current) {
                    clearInterval(typingIntervalRef.current);
                }
            };
        }, []);
        useEffect(() => {
            if (!isOpen) return;
            setIsTranslating(true);
            const translateAndSetGreeting = async () => {
                const targetLangCode = LANGUAGES[currentLanguage];
                try {
                    let finalTranslations;
                    if (!targetLangCode || targetLangCode === 'en') {
                        finalTranslations = englishDefaults;
                    } else {
                        // Proactive check for AI prompt limits
                        const usage = window.latestUsageStats;
                        if (usage && usage.at_limit && usage.at_limit.ai_prompts) {
                            throw new Error('You have reached your weekly AI prompt limit.');
                        }
                        const response = await makeAuthenticatedRequest('/api/translate', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                texts: englishDefaults,
                                target_lang: targetLangCode
                            })
                        });
                        if (!response.ok) throw new Error(`Server error: ${response.status}`);
                        const data = await response.json();
                        if (data.status === 'success') {
                            finalTranslations = data.translations;
                        } else {
                            throw new Error(data.message);
                        }
                    }
                    setUiTranslations(finalTranslations);
                    const greeting = (finalTranslations.greeting_template || englishDefaults.greeting_template)
                        .replace('{projectName}', projectName || 'project');
                    setMessages([{ role: 'model', text: greeting }]);
                } catch (error) {
                    console.error("Error fetching translations:", error);
                    setUiTranslations(englishDefaults);
                    const greeting = englishDefaults.greeting_template.replace('{projectName}', projectName || 'project');
                    setMessages([{ role: 'model', text: greeting }]);
                } finally {
                    setIsTranslating(false);
                }
            };
            translateAndSetGreeting();
        }, [currentLanguage, projectName, isOpen]);
        const sendQuery = async (queryText) => {
            if (!queryText.trim() || isLoading) return;
            if (typingIntervalRef.current) {
                clearInterval(typingIntervalRef.current);
            }
            const userMessage = { role: 'user', text: queryText };
            setMessages(prev => [...prev, userMessage]);
            setInputValue('');
            setIsLoading(true);
            const summarizeTasksForAI = (tasksToSummarize) => {
                let summarizedData = [];
                const processTask = (task) => {
                    summarizedData.push({
                        wbs: task.wbs, name: task.taskName, status: task.status,
                        progress: task.progress, planned_start: task.plannedStartDate,
                        planned_end: task.plannedEndDate, is_critical: task.isCritical,
                        predecessors: task.predecessorString
                    });
                    if (task.subtasks) task.subtasks.forEach(processTask);
                };
                tasksToSummarize.forEach(processTask);
                return JSON.stringify(summarizedData);
            };
            const projectContext = `
             You are a helpful project assistant for the "${projectName}" project.
            You must provide response in the "${currentLanguage}" language.
            The Response should have word limit of 100-150 words.
            Here is a summary of the current project tasks:
            ${summarizeTasksForAI(projectTasks)}
            ---
            INSTRUCTIONS:
            1. Format every response using simple Markdown headings, bold, bullets.
            2. NEVER mention the parameter names. For example, do not say "based on the data" or "the 'is_critical' parameter is true". Simply state the facts naturally.
            3. If it is not related to provided data, clearly state that but if the question is related to Project Management in general, you can use your general knowledge.`;
            const chatHistory = [
                { role: "user", parts: [{ text: projectContext }] },
                { role: "model", parts: [{ text: "Understood." }] },
                ...[...messages, userMessage].map(msg => ({
                    role: msg.role,
                    parts: [{ text: msg.text }]
                }))
            ];
            try {
                const payload = { contents: chatHistory, use_chatbot_key: true };

                const result = await retryApiCall(async () => {
                    const response = await makeAuthenticatedRequest('/api/gemini/generate-content', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (!response.ok) throw new Error(`API request failed: ${response.status}`);
                    return await response.json();
                }, 3, 1000, (attempt, maxRetries) => {
                    setRetryStatus(`Retrying... (${attempt}/${maxRetries})`);
                });

                const modelResponse = result.candidates?.[0]?.content?.parts?.[0]?.text || "Sorry, I couldn't process that.";
                setIsLoading(false);
                setMessages(prev => [...prev, { role: 'model', text: '' }]);
                let charIndex = 0;
                typingIntervalRef.current = setInterval(() => {
                    if (charIndex < modelResponse.length) {
                        setMessages(prev => {
                            const newMessages = [...prev];
                            const lastMessage = newMessages[newMessages.length - 1];
                            if (lastMessage && lastMessage.role === 'model') {
                                lastMessage.text = modelResponse.substring(0, charIndex + 1);
                            }
                            return newMessages;
                        });
                        charIndex++;
                    } else {
                        clearInterval(typingIntervalRef.current);
                    }
                }, 20);
            } catch (error) {
                console.error("Error calling Gemini API:", error);
                setIsLoading(false);
                setRetryStatus(null);
                setMessages(prev => [...prev, { role: 'model', text: `Sorry, an error occurred: ${error.message}` }]);
            }
        };
        const handleSendMessage = (e) => {
            e.preventDefault();
            sendQuery(inputValue);
        };
        const LoadingPlaceholder = ({ className = 'w-24 h-4' }) => {
            return React.createElement('div', { className: `bg-slate-200 rounded pulse-bg ${className}` });
        };
        return React.createElement('div', { className: 'chatbot-container' },
            React.createElement('div', { className: `chat-window ${!isOpen ? 'closed' : ''}` },
                React.createElement('div', { className: 'chat-header' },
                    React.createElement('span', null, isTranslating ? React.createElement(LoadingPlaceholder, { className: 'w-20 h-5' }) : uiTranslations.header),
                    React.createElement('select', {
                        value: currentLanguage,
                        onChange: (e) => setCurrentLanguage(e.target.value),
                        disabled: isTranslating,
                        className: 'bg-blue-800 text-white text-xs rounded p-1 focus:outline-none cursor-pointer disabled:opacity-50'
                    },
                        Object.keys(LANGUAGES).map(lang => React.createElement('option', { key: lang, value: lang }, lang))
                    ),
                    React.createElement('button', { onClick: () => setIsOpen(false) }, 'Ã—')
                ),
                React.createElement('div', { className: 'chat-messages' },
                    messages.map((msg, index) => {
                        if (index === 0 && isTranslating) {
                            return React.createElement('div', { key: 'translating-loader', className: 'chat-message model' },
                                React.createElement(LoadingPlaceholder, { className: 'w-48 h-5' })
                            );
                        }
                        return React.createElement('div', { key: index, className: `chat-message ${msg.role}` },
                            msg.role === 'model' ? React.createElement(SimpleMarkdownRenderer, { text: msg.text }) : msg.text
                        );
                    }),
                    messages.length === 1 && !isLoading && !isTranslating && (
                        React.createElement('div', { className: 'flex flex-col items-center gap-2 p-2' },
                            React.createElement('p', { className: 'text-xs text-slate-500 mb-1' }, uiTranslations.suggestions),
                            predefinedQueryKeys.map(queryKey => (
                                React.createElement('button', {
                                    key: queryKey,
                                    onClick: () => sendQuery(uiTranslations[queryKey]),
                                    className: 'w-full text-center px-3 py-1.5 bg-slate-100 text-slate-700 rounded-lg text-sm hover:bg-slate-200 transition-colors border border-slate-200'
                                }, uiTranslations[queryKey])
                            ))
                        )
                    ),
                    isLoading && React.createElement('div', { className: 'chat-message model' },
                        React.createElement('div', { className: 'flex items-center gap-2' },
                            React.createElement('div', { className: 'w-2 h-2 bg-slate-400 rounded-full animate-pulse' }),
                            React.createElement('div', { className: 'w-2 h-2 bg-slate-400 rounded-full animate-pulse delay-75' }),
                            React.createElement('div', { className: 'w-2 h-2 bg-slate-400 rounded-full animate-pulse delay-150' })
                        ),
                        retryStatus && React.createElement('div', { className: 'text-sm text-amber-600 mt-2' }, retryStatus)
                    ),
                    React.createElement('div', { ref: messagesEndRef })
                ),
                React.createElement('form', { className: 'chat-input-form', onSubmit: handleSendMessage },
                    React.createElement('input', {
                        type: 'text',
                        placeholder: isTranslating ? 'Loading...' : uiTranslations.placeholder,
                        value: inputValue,
                        onChange: (e) => setInputValue(e.target.value),
                        disabled: isLoading || isTranslating
                    }),
                    React.createElement('button', { type: 'submit', disabled: isLoading || isTranslating || !inputValue.trim() },
                        React.createElement(SendIcon, { size: 16 })
                    )
                )
            ),
            React.createElement('button', {
                className: 'chatbot-toggle-button chatbot-fab help-chat-button',
                onClick: () => setIsOpen(prev => !prev)
            }, React.createElement(ChatIcon, { size: 28 }))
        );
    };

    const imageToBase64 = async (url) => {
        const response = await fetch(url);
        const blob = await response.blob();
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });
    };

</script>