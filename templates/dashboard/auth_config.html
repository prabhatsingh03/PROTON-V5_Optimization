<script>
    // Ensure Razorpay checkout script is loaded
    (function ensureRazorpayScript() {
        if (!document.querySelector('script[src*="checkout.razorpay.com"]')) {
            const s = document.createElement('script');
            s.src = 'https://checkout.razorpay.com/v1/checkout.js';
            s.async = true;
            document.head.appendChild(s);
        }
    })();

    // Expose global Razorpay checkout handlers
    window.openRazorpayCheckout = function (subscriptionData) {
        if (!subscriptionData || !subscriptionData.subscription_id || !subscriptionData.razorpay_key_id) {
            alert('Payment data missing.');
            return;
        }
        const options = {
            key: subscriptionData.razorpay_key_id,
            subscription_id: subscriptionData.subscription_id,
            name: 'PROTON',
            description: 'Subscription Payment',
            theme: { color: '#8b5cf6' },
            handler: function (response) {
                window.verifyPayment(response);
            },
            modal: {
                ondismiss: function () {
                    // Handle abandoned payment
                    console.log('Payment modal closed by user');
                    if (subscriptionData.subscription_id) {
                        makeAuthenticatedRequest('/api/razorpay/subscription/abandon', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ subscription_id: subscriptionData.subscription_id })
                        }).then(r => r.json()).then(d => {
                            console.log('Abandonment logged:', d);
                            alert('Payment was cancelled. Your subscription was not upgraded.');
                            if (typeof window.refreshSubscriptionData === 'function') window.refreshSubscriptionData();
                        }).catch(e => console.error('Failed to log abandonment', e));
                    }
                }
            }
        };
        if (typeof Razorpay !== 'undefined') {
            const rz = new Razorpay(options);
            rz.open();
        } else {
            alert('Payment is not ready yet. Please try again in a moment.');
        }
    };

    window.verifyPayment = async function (resp) {
        try {
            const r = await makeAuthenticatedRequest('/api/razorpay/subscription/verify', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(resp)
            });
            const data = await r.json();
            if (data.status === 'success') {
                if (typeof window.refreshUsageStats === 'function') window.refreshUsageStats();
                if (typeof window.refreshSubscriptionData === 'function') window.refreshSubscriptionData();
                alert('Subscription upgraded successfully!');
            } else {
                alert(data.message || 'Payment verification failed');
            }
        } catch (e) {
            alert('Payment verification failed');
        }
    };
    // ============================================================================
    // CLIENT-SIDE AUTHENTICATION CHECK
    // ============================================================================
    // This check ensures users are authenticated before accessing dashboard pages.
    // If no valid JWT tokens are found in localStorage, users are redirected to /
    // This pattern is used for all HTML routes (/, /dashboard, /charts, etc.)
    // Server-side authentication is only used for API routes (/api/*)
    // ============================================================================
    // Check for new JWT tokens, clear old format if exists
    const accessToken = localStorage.getItem('access_token');
    const userData = localStorage.getItem('user_data');

    if (!accessToken || !userData) {
        // Migrate from old auth format if needed
        const oldAuth = localStorage.getItem('aiProjectControlTowerAuth_v2');
        if (oldAuth) {
            localStorage.removeItem('aiProjectControlTowerAuth_v2');
        }
        // Redirect to landing page
        window.location.href = '/';
    }

    // Log current origin for troubleshooting API connection issues
    // Only log in development (when running on localhost/127.0.0.1)
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
        console.log('[Dashboard] Development mode detected');
        console.log('[Dashboard] Page origin:', window.location.origin);
        console.log('[Dashboard] API endpoint base:', window.location.origin + '/api');
        console.log('[Dashboard] Ensure Flask server is running on port', window.location.port || '80');
    }
</script>

<script type="text/babel">
    /*
     * ============================================================================
     * DASHBOARD APPLICATION - API ARCHITECTURE
     * ============================================================================
     * 
     * This dashboard uses a client-side React application that communicates with
     * a Flask backend API using JWT authentication.
     * 
     * API ENDPOINT PATTERN:
     * 
     * - All API calls use RELATIVE URLs (e.g., '/api/upload', '/api/projects')
     * - Browser automatically resolves relative URLs against window.location.origin
     * - This ensures API calls always go to the same server that served the page
     * 
     * AUTHENTICATION:
     * 
     * - JWT tokens stored in localStorage (access_token, refresh_token)
     * - makeAuthenticatedRequest() wrapper adds Authorization header automatically
     * - Expired tokens are automatically refreshed once (401 response)
     * - Failed refresh redirects to landing page for re-login
     * 
     * KEY FUNCTIONS:
     * 
     * - makeAuthenticatedRequest(url, options): Authenticated fetch wrapper
     * - refreshAccessToken(): Refresh expired JWT token
     * - handleFileUpload(event): CSV file upload for task import
     * - saveDataToServer(tasks): Save task changes to backend
     * - loadProjectData(projectName): Load project tasks from backend
     * 
     * API ENDPOINTS USED:
     * 
     * - POST /api/upload?project=<name> - Upload CSV file
     * - GET /api/load?project=<name> - Load project tasks
     * - POST /api/save?project=<name> - Save task changes
     * - POST /api/add_task?project=<name> - Add new task
     * - POST /api/delete_task?project=<name> - Delete task
     * - POST /api/update_task?project=<name> - Update single task
     * - GET /api/projects - List all projects
     * - POST /api/projects - Create new project
     * - GET /api/org/usage - Get organization usage stats
     * - GET /api/org/subscription - Get subscription details
     * - And many more... (see makeAuthenticatedRequest usage throughout)
     * 
     * IMPORTANT NOTES:
     * 
     * - Never use absolute URLs (e.g., 'http://127.0.0.1:5000/api/upload')
     * - Always use relative URLs (e.g., '/api/upload')
     * - Always encode query parameters with encodeURIComponent()
     * - Always encode path parameters with encodeURIComponent()
     * - FormData uploads automatically set correct Content-Type header
     * 
     * TROUBLESHOOTING:
     * 
     * - See detailed troubleshooting guide below (search for "TROUBLESHOOTING")
     * - Check browser console for diagnostic logs on page load
     * - Verify Flask server is running on same port as page
     * 
     * ============================================================================
     */

    /*
     * ============================================================================
     * API ENDPOINT CONFIGURATION & TROUBLESHOOTING
     * ============================================================================
     * 
     * This application uses RELATIVE URLs for all API calls (e.g., '/api/upload').
     * The browser automatically resolves these against window.location.origin.
     * 
     * Example:
     * - If page is served from: http://127.0.0.1:5000/dashboard
     * - Then '/api/upload' becomes: http://127.0.0.1:5000/api/upload
     * 
     * TROUBLESHOOTING CONNECTION ERRORS:
     * 
     * 1. ERR_CONNECTION_REFUSED:
     *    - Symptom: API calls fail with "net::ERR_CONNECTION_REFUSED"
     *    - Cause: Flask server is not running on the expected port
     *    - Solution: 
     *      a) Check window.location.origin in browser console
     *      b) Ensure Flask server is running on the same port
     *      c) Default Flask port is 5000, but can be changed with --port flag
     *      d) Example: python app.py --port 5000
     * 
     * 2. Port Mismatch:
     *    - Symptom: API calls go to wrong port (e.g., 5125 instead of 5000)
     *    - Cause: Page was accessed via wrong port or browser cached old page
     *    - Solution:
     *      a) Clear browser cache (Ctrl+Shift+Delete)
     *      b) Hard refresh (Ctrl+F5 or Cmd+Shift+R)
     *      c) Access page via correct port: http://127.0.0.1:5000/dashboard
     *      d) Check Flask server logs to confirm which port it's running on
     * 
     * 3. CORS Errors:
     *    - Symptom: "Access-Control-Allow-Origin" errors in console
     *    - Cause: API requests going to different origin than page
     *    - Solution: Ensure page and API are served from same origin
     * 
     * 4. 401 Unauthorized:
     *    - Symptom: API calls return 401 status
     *    - Cause: JWT token expired or invalid
     *    - Solution: Token is automatically refreshed once; if persists, re-login
     * 
     * 5. 403 Forbidden (Plan Limit):
     *    - Symptom: API calls return 403 with PLAN_LIMIT_EXCEEDED error
     *    - Cause: Organization has exceeded plan limits
     *    - Solution: Upgrade plan or contact admin
     * 
     * IMPORTANT: Never use absolute URLs (e.g., 'http://127.0.0.1:5000/api/upload')
     *            Always use relative URLs (e.g., '/api/upload')
     *            This ensures API calls always go to the same origin as the page.
     * 
     * ============================================================================
     */

    // --- Configuration & Constants ---
    const APP_TITLE = "PROTON ";
    const APP_TITLE2 = " by Simon India Limited";
    const TASK_STATUSES = ['Not Started', 'In Progress', 'Completed', 'Delayed', 'On Hold', 'Ahead of Schedule'];
    const CLIENT_COMMENT_STATUSES = ['Acknowledged', 'Approved', 'Return with Comments', 'Hold for Review'];

    const generateUUID = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => { const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); });

    // Helper function to base64url-decode JWT payloads
    // Replaces base64url characters (- → +, _ → /) and adds padding (=)
    function decodeBase64Url(base64Url) {
        let base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
        while (base64.length % 4) {
            base64 += '=';
        }
        return atob(base64);
    }

    // Session Timeout Handler Functions
    // Check if JWT token is expired
    function isTokenExpired(token) {
        if (!token) return true;
        try {
            let payload = token.split('.')[1];
            payload = payload.replace(/-/g, '+').replace(/_/g, '/');
            while (payload.length % 4) {
                payload += '=';
            }
            const decoded = JSON.parse(atob(payload));
            if (decoded.exp) {
                const expDate = new Date(decoded.exp * 1000);
                return expDate < new Date();
            }
            return false;
        } catch {
            return true;
        }
    }

    // Show session timeout message and redirect
    function handleSessionTimeout() {
        // Clear all auth data
        localStorage.removeItem('access_token');
        localStorage.removeItem('refresh_token');
        localStorage.removeItem('user_data');
        localStorage.removeItem('aiProjectControlTowerAuth_v2');
        sessionStorage.removeItem('trial_banner_dismissed');
        sessionStorage.removeItem('trial_banner_dismissed_at');

        // Show timeout message
        const root = document.getElementById('root');
        if (root) {
            root.innerHTML = `
                <div class="min-h-screen flex items-center justify-center bg-gradient-to-br from-slate-50 to-slate-100">
                    <div class="text-center p-8 bg-white rounded-2xl shadow-xl border border-slate-200 max-w-md">
                        <div class="mb-6">
                            <div class="mx-auto w-16 h-16 bg-gradient-to-br from-amber-400 to-orange-500 rounded-full flex items-center justify-center mb-4">
                                <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                </svg>
                            </div>
                            <h2 class="text-2xl font-bold text-slate-800 mb-2">Session Timed Out</h2>
                            <p class="text-slate-600 mb-4">Your session has expired for security reasons.</p>
                            <p class="text-sm text-slate-500 mb-6">Redirecting to login...</p>
                            <div class="flex justify-center">
                                <div class="animate-spin h-8 w-8 border-4 border-slate-200 border-t-indigo-600 rounded-full"></div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Redirect after 2 seconds
        setTimeout(() => {
            window.location.href = '/';
        }, 2000);
    }

    // JWT Authentication Helper Functions
    const refreshAccessToken = async () => {
        const refreshToken = localStorage.getItem('refresh_token');
        if (!refreshToken) {
            handleSessionTimeout();
            return false;
        }

        try {
            const response = await fetch('/api/refresh', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ refresh_token: refreshToken })
            });

            if (response.ok) {
                const data = await response.json();
                if (data && data.access_token) {
                    localStorage.setItem('access_token', data.access_token);
                    return true;
                }
            }
            // Refresh failed - show session timeout
            handleSessionTimeout();
            return false;
        } catch (error) {
            // Refresh failed - show session timeout
            handleSessionTimeout();
            return false;
        }
    };

    /**
     * Authenticated API request wrapper
     * 
     * @param {string} url - Relative URL path (e.g., '/api/upload', '/api/projects')
     *                       IMPORTANT: Always use relative URLs starting with '/'
     *                       The browser will automatically resolve against window.location.origin
     * @param {Object} options - Standard fetch options (method, headers, body, etc.)
     * @returns {Promise<Response>} - Fetch Response object
     * 
     * Features:
     * - Automatically adds JWT Authorization header
     * - Handles token refresh on 401 (expired token)
     * - Handles plan limit errors on 403 with user notifications
     * - Supports FormData uploads (preserves multipart/form-data content type)
     * 
     * Troubleshooting:
     * - ERR_CONNECTION_REFUSED: Server not running on expected port
     *   Check that Flask server port matches window.location.origin
     *   Example: If page is at http://127.0.0.1:5000, server must run on port 5000
     * - 401 Unauthorized: Token expired or invalid (auto-refreshed once)
     * - 403 Forbidden: Plan limit exceeded (shows upgrade notification)
     */
    const makeAuthenticatedRequest = async (url, options = {}) => {
        // Defensive check: Warn if URL is not relative
        if (!url.startsWith('/')) {
            console.warn(`[makeAuthenticatedRequest] Warning: URL should be relative (start with '/'): ${url}`);
            console.warn(`[makeAuthenticatedRequest] Current origin: ${window.location.origin}`);
        }

        let accessToken = localStorage.getItem('access_token');

        // Check if token is expired before making request
        if (isTokenExpired(accessToken)) {
            const newToken = await refreshAccessToken();
            if (!newToken || isTokenExpired(newToken)) {
                throw new Error('Session expired');
            }
            accessToken = localStorage.getItem('access_token');
        }

        // Handle FormData specially - only add Authorization, don't touch Content-Type
        if (options.body instanceof FormData) {
            options = {
                ...options,
                headers: {
                    ...options.headers,
                    'Authorization': 'Bearer ' + accessToken
                }
            };
        } else {
            // For non-FormData requests, ensure headers object exists
            if (!options.headers) {
                options.headers = {};
            }
            // Add Authorization header
            options.headers['Authorization'] = 'Bearer ' + accessToken;
        }

        // Make the request
        // Relative URL is resolved by browser against window.location.origin
        // Example: '/api/upload' becomes 'http://127.0.0.1:5000/api/upload' if page is served from port 5000
        let response = await fetch(url, options);

        // If 401, try to refresh token and retry once
        if (response.status === 401) {
            const refreshSuccess = await refreshAccessToken();
            if (refreshSuccess) {
                const newAccessToken = localStorage.getItem('access_token');
                if (newAccessToken && !isTokenExpired(newAccessToken)) {
                    // Reconstruct options for retry
                    if (options.body instanceof FormData) {
                        options = {
                            ...options,
                            headers: {
                                ...options.headers,
                                'Authorization': 'Bearer ' + newAccessToken
                            }
                        };
                    } else {
                        options.headers['Authorization'] = 'Bearer ' + newAccessToken;
                    }

                    response = await fetch(url, options);
                } else {
                    throw new Error('Session expired');
                }
            } else {
                throw new Error('Session expired');
            }
        }

        // Plan limit error handling and usage refresh
        if (response.status === 403) {
            try {
                const clone = response.clone();
                const data = await clone.json();
                if (data && data.error_code === 'PLAN_LIMIT_EXCEEDED') {
                    const role = (window.loggedInUser && window.loggedInUser.role) || 'org_user';
                    const isAdmin = role === 'org_admin' || role === 'super_admin';
                    const upgradeUrl = data.upgrade_url || '/upgrade';
                    const suggested = data.suggested_plan ? ` Upgrade to ${data.suggested_plan}.` : '';
                    const message = (data.message || 'Plan limit reached.') + suggested;
                    const action = isAdmin
                        ? { label: 'Upgrade Now', onClick: () => { window.location.href = upgradeUrl; } }
                        : { label: 'Contact Admin', onClick: () => { try { alert('Please contact your Organization Admin to upgrade your plan.'); } catch (e) { } } };
                    if (typeof window.showNotification === 'function') {
                        window.showNotification({ message, type: 'error', action, duration: 12000 });
                    }
                    if (typeof window.refreshUsageStats === 'function') {
                        window.refreshUsageStats();
                    }
                    try { window.dispatchEvent(new CustomEvent('planLimitExceeded', { detail: data })); } catch (e) { }
                }
            } catch (e) { }
        }

        return response;
    };
</script>