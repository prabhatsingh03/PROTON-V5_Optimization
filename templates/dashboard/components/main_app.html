<!--
  LEGACY COMPONENT - PRESERVED FOR BACKWARD COMPATIBILITY
  
  This is the original monolithic React component (1366 lines) that powered
  the old dashboard. It has been refactored and distributed across multiple
  new components:
  
  - dashboard_app.html (main dashboard with KPIs)
  - projects_app.html (projects list)
  - workspace_app.html (project workspace container)
  - overview_tab.html, wbs_tab.html, gantt_tab.html, etc. (workspace tabs)
  - reports_app.html, admin_panel_app.html, client_view_app.html (new pages)
  
  This file is kept for:
  1. Backward compatibility with any legacy routes
  2. Reference for functionality that may need to be ported
  3. Fallback in case issues are found with new components
  
  DO NOT MODIFY THIS FILE unless fixing critical bugs.
  All new development should happen in the new component files.
  
  Migration date: [TO BE FILLED]
  Last verified: [TO BE FILLED]
-->
<script type="text/babel">
    const App = () => {
        const { useState, useEffect, useCallback, useMemo } = React;
        const [loggedInUser, setLoggedInUser] = useState(null);
        const [isLoading, setIsLoading] = useState(true);
        const [appError, setAppError] = useState(null);
        const [notification, setNotification] = useState(null);
        const [projects, setProjects] = useState([]);
        const [selectedProject, setSelectedProject] = useState('');
        const [tasks, setTasks] = useState([]);
        const [pendingAdmins, setPendingAdmins] = useState([]);
        const [currentView, setCurrentView] = useState('admin');
        const [showEditModal, setShowEditModal] = useState(false);
        const [showAIModal, setShowAIModal] = useState(false);
        const [showNotesModal, setShowNotesModal] = useState(false);
        const [showClientCommModal, setShowClientCommModal] = useState(false);
        const [showAddProjectModal, setShowAddProjectModal] = useState(false);
        const [showAddTaskModal, setShowAddTaskModal] = useState(false);
        const [showDetailsModal, setShowDetailsModal] = useState(false);
        const [showActivityLogModal, setShowActivityLogModal] = useState(false);
        const [showCSVImportModal, setShowCSVImportModal] = useState(false);
        const [showUserManagementModal, setShowUserManagementModal] = useState(false);
        const [showSubscriptionManagement, setShowSubscriptionManagement] = useState(false);
        const [subscriptionData, setSubscriptionData] = useState(null);
        const [trialStatus, setTrialStatus] = useState(null);
        const [isTrialBannerDismissed, setIsTrialBannerDismissed] = useState(false);
        const isTrialExpired = !!(trialStatus && trialStatus.is_trial && trialStatus.is_expired);
        const [selectedTask, setSelectedTask] = useState(null);
        const [addTaskContext, setAddTaskContext] = useState(null);
        const [searchTerm, setSearchTerm] = useState('');
        const [startDateFilter, setStartDateFilter] = useState('');
        const [endDateFilter, setEndDateFilter] = useState('');
        const [sortBy, setSortBy] = useState({ field: 'wbs', order: 'asc' });
        const [areAllExpanded, setAreAllExpanded] = useState(true);
        const [isSidebarOpen, setIsSidebarOpen] = useState(false);
        const [dashboardData, setDashboardData] = useState(null);
        const [showNotificationDropdown, setShowNotificationDropdown] = useState(false);
        const [showTutorial, setShowTutorial] = useState(false);
        const [tutorialSteps, setTutorialSteps] = useState([
            {
                id: "step1",
                title: "Step 1 — Add Project",
                body: "Create a new project here. Click 'Add Project' to start managing a new project workspace.",
                selector: ".btn-add-project, #add-project, .add-project-btn",
                placement: "bottom"
            },
            {
                id: "step2",
                title: "Step 2 — Import CSV",
                body: "Import tasks or bulk data quickly using the CSV importer. Use this to set up tasks in bulk.",
                selector: ".import-csv-btn, #importCSV, .btn-import-csv",
                placement: "bottom"
            },
            {
                id: "step3",
                title: "Step 3 — Overall Project Progress",
                body: "Monitor actual vs planned progress here — the progress bar gives you a quick health snapshot of your project.",
                selector: ".overall-project-progress, .progress-bar, #project-progress",
                placement: "bottom"
            },
            {
                id: "step4",
                title: "Step 4 — Action Buttons for Tasks",
                body: "Use quick actions to comment, edit, move or delete tasks. These action buttons let you manage tasks fast.",
                selector: ".task-actions, .actions-cell, .task-row .actions",
                placement: "left"
            },
            {
                id: "step5",
                title: "Step 5 — Gantt Chart",
                body: "View the Gantt chart to see task timelines and dependencies. Toggle this view to analyze schedules.",
                selector: ".gantt-toggle, #ganttChart, .export-gantt",
                placement: "right"
            },
            {
                id: "step6",
                title: "Step 6 — AI Risk Assessment",
                body: "AI-powered risk detection highlights tasks with potential schedule or cost risks. Check the risk card for insights.",
                selector: ".ai-risk-card, #riskAssessment, .risk-widget",
                placement: "right"
            },
            {
                id: "step7",
                title: "Step 7 — Chatbot",
                body: "Ask the virtual assistant questions about project status, find tasks or request reports using the chatbot.",
                selector: ".chatbot-fab, #chatbot, .help-chat-button",
                placement: "left"
            },
            {
                id: "step8",
                title: "Step 8 — Activity Log",
                body: "See an audit trail of changes and recent actions in the activity log for compliance and tracking.",
                selector: ".activity-log, #activityLog, .activity-button",
                placement: "left",
                adminOnly: true
            },
            {
                id: "step9",
                title: "Step 9 — Add Users (Admins Only)",
                body: "Invite team members and assign roles. Only available to organization admins.",
                selector: ".btn-add-user, #addUser, .manage-users-btn",
                placement: "bottom",
                adminOnly: true
            }
        ]);

        // --- Role-Based UI Helper Functions (already defined above for TaskRow access) ---
        // Note: These functions are defined before TaskRow component for scope access

        // --- Role Badge Helper ---
        const getRoleBadge = (role) => {
            const badges = {
                'super_admin': { label: 'Super Admin', color: 'bg-purple-100 text-purple-700' },
                'org_admin': { label: 'Org Admin', color: 'bg-blue-100 text-blue-700' },
                'org_user': { label: 'User', color: 'bg-green-100 text-green-700' },
                'client': { label: 'Client', color: 'bg-slate-100 text-slate-700' }
            };
            
            const badge = badges[role] || badges['org_user'];
            
            return React.createElement('span', {
                className: `px-2 py-1 text-xs font-semibold rounded-full ${badge.color}`
            }, badge.label);
        };

        // --- Role-Based Welcome Message ---
        const getWelcomeMessage = (role) => {
            const messages = {
                'super_admin': 'Welcome, Super Admin! You have full system access.',
                'org_admin': 'Welcome, Organization Admin! Manage your team and projects.',
                'org_user': 'Welcome! View and update your assigned tasks.',
                'client': 'Welcome! View your project deliverables.'
            };
            return messages[role] || 'Welcome to PROTON!';
        };

        // --- Centralized API 403 Error Handler ---
        const handleAPIError = (response, data) => {
            if (response && response.status === 403) {
                const msg = (loggedInUser && loggedInUser.role === 'org_user')
                    ? 'This action requires Org Admin privileges.'
                    : (data && data.message) || 'You do not have permission to perform this action.';
                setAppError(msg);
                return true;
            }
            return false;
        };


        const openEditModal = (task) => { setSelectedTask(task); setShowEditModal(true); };
        const openAIModal = (task) => { setSelectedTask(task); setShowAIModal(true); };
        const openNotesModal = (task) => { setSelectedTask(task); setShowNotesModal(true); };
        const openClientCommModal = (task) => {
            // When an admin opens the modal, find ALL unread comments for that task and mark them as seen.
            if (loggedInUser.userType !== 'client') {
                const unreadCommentsExist = task.clientComments && task.clientComments.some(c => c.clientStatus && c.adminSeen === false);
                if (unreadCommentsExist) {
                    const updatedComments = task.clientComments.map(c =>
                        (c.clientStatus && c.adminSeen === false) ? { ...c, adminSeen: true } : c
                    );
                    handleUpdateTask(task.id, { clientComments: updatedComments });
                }
            }
            setSelectedTask(task);
            setShowClientCommModal(true);
        };

        const openDetailsModal = (task) => { setSelectedTask(task); setShowDetailsModal(true); };
        const openAddTaskModal = (task, mode) => { setAddTaskContext({ task, mode }); setShowAddTaskModal(true); };

        // Trial banner handlers
        const handleDismissTrialBanner = () => {
            setIsTrialBannerDismissed(true);
            sessionStorage.setItem('trial_banner_dismissed', 'true');
        };

        const handleTrialUpgrade = () => {
            setShowSubscriptionManagement(true);
        };

        const APP_SUBTITLE = selectedProject || "No Project Selected";

        useEffect(() => {
            const accessToken = localStorage.getItem('access_token');
            const userData = localStorage.getItem('user_data');
            
            if (accessToken && userData) {
                try {
                    const authData = JSON.parse(userData);
                    
                    // Parse role from JWT token
                    let userRole = 'org_user'; // default fallback
                    let orgId = null;
                    let plan = null;
                    
                    try {
                        // JWT format: header.payload.signature
                        const payload = accessToken.split('.')[1];
                        const decodedPayload = JSON.parse(decodeBase64Url(payload));
                        userRole = decodedPayload.role || 'org_user';
                        orgId = decodedPayload.org_id || null;
                        plan = decodedPayload.plan || null;
                    } catch (jwtError) {
                        console.warn('Failed to parse JWT token:', jwtError);
                        // Fallback to userType for backward compatibility
                        if (authData.userType === 'admin') {
                            userRole = 'org_admin'; // fallback for existing admin users
                        }
                    }
                    
                    // Enhanced authData with role information
                    const enhancedAuthData = {
                        ...authData,
                        role: userRole,
                        org_id: orgId,
                        plan: plan
                    };
                    
                    setLoggedInUser(enhancedAuthData);
                    // Expose loggedInUser and a global notifier for centralized handlers
                    try {
                        window.loggedInUser = enhancedAuthData;
                        window.showNotification = ({ message, type = 'info', action, duration }) => {
                            setNotification({ message, type, action, duration });
                        };
                    } catch (e) {}
                    if (authData.userType === 'client') {
                        setCurrentView('client');
                        setSelectedProject(authData.project);
                    }
                } catch (e) {
                    localStorage.removeItem('access_token');
                    localStorage.removeItem('refresh_token');
                    localStorage.removeItem('user_data');
                }
            } else {
                // Clean up legacy auth format if present
                localStorage.removeItem('aiProjectControlTowerAuth_v2');
                setIsLoading(false);
            }
        }, []);

        useEffect(() => {
            window.openSubscriptionManagement = () => setShowSubscriptionManagement(true);
            return () => { try { delete window.openSubscriptionManagement; } catch (e) {} };
        }, []);

        useEffect(() => {
            if (loggedInUser) {
                setIsLoading(true);
                makeAuthenticatedRequest('/api/projects', { method: 'GET', headers: { 'Content-Type': 'application/json' } })
                    .then(res => res.json())
                    .then(data => {
                        // Handle error responses (non-array) and ensure projects is always an array
                        if (Array.isArray(data)) {
                            setProjects(data);
                            if (loggedInUser.userType !== 'client' && data.length > 0 && !selectedProject) {
                                setSelectedProject(data[0].name);
                            }
                        } else if (data && data.status === 'error') {
                            console.error('Projects API error:', data.message);
                            setAppError(data.message || 'Could not load projects list.');
                            setProjects([]);
                        } else {
                            setProjects([]);
                        }
                    })
                    .catch(err => {
                        setAppError('Could not load projects list.');
                        setProjects([]);
                    })
                    .finally(() => {
                        // Only set loading to false if we're not a client or if we don't have a selected project
                        // For clients, the loading will be managed by the task loading in loadInitialData
                        if (loggedInUser.userType !== 'client' || !selectedProject) {
                            setIsLoading(false);
                        }
                    });

                if (loggedInUser.userType === 'super_admin') {
                    makeAuthenticatedRequest('/api/pending_admins', { method: 'GET', headers: { 'Content-Type': 'application/json' } })
                        .then(res => res.json())
                        .then(data => setPendingAdmins(data))
                        .catch(err => console.error("Could not fetch pending admins"));
                }
            }
        }, [loggedInUser]);

        // Fetch trial status when user logs in
        useEffect(() => {
            if (loggedInUser && loggedInUser.role !== 'super_admin' && loggedInUser.userType !== 'client') {
                // Fetch trial status
                makeAuthenticatedRequest('/api/org/trial-status', {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                })
                .then(res => res.json())
                .then(data => {
                    if (data.status === 'success') {
                        setTrialStatus(data);
                    }
                })
                .catch(err => {
                    console.error('Failed to fetch trial status:', err);
                    // Don't show error - banner simply won't appear
                });
                
                // Check if banner was dismissed
                const dismissed = sessionStorage.getItem('trial_banner_dismissed') === 'true';
                setIsTrialBannerDismissed(dismissed);
            }
        }, [loggedInUser]);

        // Tutorial event listener
        useEffect(() => {
            const handleStartTutorial = () => {
                setShowTutorial(true);
            };
            
            window.addEventListener('startOnboardingTour', handleStartTutorial);
            
            return () => {
                window.removeEventListener('startOnboardingTour', handleStartTutorial);
            };
        }, []);

        const normalizeTasks = (tasksToNormalize) => {
            if (!tasksToNormalize || !Array.isArray(tasksToNormalize)) return [];
            return tasksToNormalize.map(t => {
                const subtasks = (t.subtasks && t.subtasks.length > 0) ? normalizeTasks(t.subtasks) : [];

                return {
                    id: t.id || generateUUID(),
                    wbs: t.wbs || '',
                    taskName: t.taskName || '',
                    plannedStartDate: parseCSVDate(t.plannedStartDate || ''),
                    plannedEndDate: parseCSVDate(t.plannedEndDate || ''),
                    predecessorString: t.predecessorString || '',
                    originalDurationDays: String(t.originalDurationDays || '0').replace(' days', ''),
                    weightage: t.weightage ?? 0,
                    actualStartDate: parseCSVDate(t.actualStartDate || ''),
                    actualEndDate: parseCSVDate(t.actualEndDate || ''),
                    progress: t.progress || 0, // Will be recalculated
                    status: t.status || 'Not Started',
                    notes: Array.isArray(t.notes) ? t.notes : (typeof t.notes === 'string' && t.notes.trim() ? [{ text: t.notes, timestamp: new Date().toISOString(), source: 'AI Risk Assessment' }] : []),
                    isClientDeliverable: t.isClientDeliverable || false,
                    isCritical: t.isCritical || false,
                    dependencies: t.dependencies || [],
                    clientComments: (t.clientComments || []).map(c => ({ ...c, id: c.id || generateUUID() })), // Ensure comments have IDs
                    delayWeatherDays: t.delayWeatherDays || 0,
                    delayContractorDays: t.delayContractorDays || 0,
                    delayClientDays: t.delayClientDays || 0,
                    isExpanded: t.isExpanded !== undefined ? t.isExpanded : true,
                    subtasks: subtasks
                };
            });
        };

        const [currentPage, setCurrentPage] = useState(1);
        const [hasMoreTasks, setHasMoreTasks] = useState(true);
        const [isLoadingMore, setIsLoadingMore] = useState(false);

        const loadInitialData = useCallback((projectName) => {
            setIsLoading(true);
            setCurrentPage(1);
            setHasMoreTasks(true);

            makeAuthenticatedRequest(`/api/load?project=${encodeURIComponent(projectName)}&page=1&per_page=50`, { method: 'GET', headers: { 'Content-Type': 'application/json' } })
                .then(res => res.ok ? res.json() : res.json().then(err => Promise.reject(err)))
                .then(response => {
                    const raw = response.data || response; // Handle both paginated and non-paginated responses
                    const normalized = normalizeTasks(raw || []);
                    setTasks(recalculateParentProgress(normalized));

                    // Update pagination state
                    if (response.pagination) {
                        setHasMoreTasks(response.pagination.has_more);
                    }
                })
                .catch(err => setAppError(`Could not load tasks for ${projectName}: ${err.message}`))
                .finally(() => setIsLoading(false));

            makeAuthenticatedRequest(`/api/chart_data?project=${encodeURIComponent(projectName)}`, { method: 'GET', headers: { 'Content-Type': 'application/json' } })
                .then(res => res.json())
                .then(data => setDashboardData(data))
                .catch(err => console.error("Failed to load dashboard data:", err));
        }, []);

        const loadMoreTasks = useCallback(() => {
            if (isLoadingMore || !hasMoreTasks || !selectedProject) return;

            setIsLoadingMore(true);
            const nextPage = currentPage + 1;

            makeAuthenticatedRequest(`/api/load?project=${encodeURIComponent(selectedProject)}&page=${nextPage}&per_page=50`, { method: 'GET', headers: { 'Content-Type': 'application/json' } })
                .then(res => res.ok ? res.json() : res.json().then(err => Promise.reject(err)))
                .then(response => {
                    const newTasks = response.data || [];
                    const normalized = normalizeTasks(newTasks);

                    setTasks(prevTasks => {
                        const updatedTasks = [...prevTasks, ...recalculateParentProgress(normalized)];
                        return updatedTasks;
                    });

                    setCurrentPage(nextPage);
                    if (response.pagination) {
                        setHasMoreTasks(response.pagination.has_more);
                    }
                })
                .catch(err => console.error("Failed to load more tasks:", err))
                .finally(() => setIsLoadingMore(false));
        }, [currentPage, hasMoreTasks, selectedProject, isLoadingMore]);

        // Helper function to fetch trial status
        const fetchTrialStatus = useCallback(() => {
            if (!loggedInUser || loggedInUser.role === 'super_admin' || loggedInUser.userType === 'client') {
                return;
            }
            
            makeAuthenticatedRequest('/api/org/trial-status', {
                method: 'GET',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(res => res.json())
            .then(data => {
                if (data.status === 'success') {
                    setTrialStatus(data);
                }
            })
            .catch(err => console.error('Failed to fetch trial status:', err));
        }, [loggedInUser]);

        useEffect(() => {
            if (loggedInUser && selectedProject) {
                loadInitialData(selectedProject);
            } else {
                setTasks([]);
            }
        }, [loggedInUser, selectedProject, loadInitialData]);

        const recalculateParentProgress = (taskList) => {
            return taskList.map(task => {
                if (task.subtasks && task.subtasks.length > 0) {
                    const updatedSubtasks = recalculateParentProgress(task.subtasks);
                    let totalWeight = 0;
                    let weightedProgressSum = 0;
                    updatedSubtasks.forEach(st => {
                        const weight = parseFloat(st.weightage ?? 0);
                        const progress = parseFloat(st.progress || 0);
                        if (!isNaN(weight) && !isNaN(progress)) {
                            totalWeight += weight;
                            weightedProgressSum += progress * weight;
                        }
                    });
                    const newProgress = totalWeight > 0 ? parseFloat((weightedProgressSum / totalWeight).toFixed(2)) : 0;
                    return { ...task, subtasks: updatedSubtasks, progress: newProgress };
                }
                return task;
            });
        };

        // Tutorial completion handler
        const handleTutorialComplete = () => {
            localStorage.setItem('tourSeenByUser', '1');

            const orgId = window.__ORG_ID__;
            if (!orgId) {
                setShowTutorial(false);
                return;
            }

            if (!window.__ORG_TOUR_SEEN__) {
                makeAuthenticatedRequest('/api/org/tour-seen', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ orgId })
                })
                .then(res => {
                    if (res.ok) {
                        window.__ORG_TOUR_SEEN__ = true;
                    } else {
                        console.warn('Failed to mark tour as seen on server.', res.status);
                    }
                })
                .catch(err => {
                    console.warn('Failed to mark tour as seen on server:', err);
                })
                .finally(() => {
                    setShowTutorial(false);
                });
                return;
            }

            setShowTutorial(false);
        };

        // Tutorial skip handler
        const handleTutorialSkip = () => {
            localStorage.setItem('tourSeenByUser', '1');

            const orgId = window.__ORG_ID__;
            if (!orgId) {
                setShowTutorial(false);
                return;
            }

            if (!window.__ORG_TOUR_SEEN__) {
                makeAuthenticatedRequest('/api/org/tour-seen', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ orgId })
                })
                .then(res => {
                    if (res.ok) {
                        window.__ORG_TOUR_SEEN__ = true;
                    } else {
                        console.warn('Failed to mark tour as seen on server.', res.status);
                    }
                })
                .catch(err => {
                    console.warn('Failed to mark tour as seen on server:', err);
                })
                .finally(() => {
                    setShowTutorial(false);
                });
                return;
            }

            setShowTutorial(false);
        };

        // Manual restart handler
        const handleShowTutorial = () => {
            setShowTutorial(true);
        };

        const handleUpdateTask = useCallback((taskId, updatedData) => {
            const originalTasks = tasks; // Keep a copy of the original state to revert on error

            // Optimistically update UI
            const updateTaskRecursively = (taskList, id, data) => {
                return taskList.map(task => {
                    if (task.id === id) {
                        return { ...task, ...data };
                    }
                    if (task.subtasks && task.subtasks.length > 0) {
                        return { ...task, subtasks: updateTaskRecursively(task.subtasks, id, data) };
                    }
                    return task;
                });
            };

            const optimisticallyUpdatedTasks = updateTaskRecursively(tasks, taskId, updatedData);
            const finalTasksState = recalculateParentProgress(optimisticallyUpdatedTasks);
            setTasks(finalTasksState);

            // Prepare payload for the efficient endpoint
            const payload = {
                taskId: taskId,
                updatedData: updatedData,
                user_email: loggedInUser.email
            };

            // Call the efficient endpoint
            makeAuthenticatedRequest(`/api/update_task?project=${encodeURIComponent(selectedProject)}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
                .then(res => {
                    if (!res.ok) {
                        // If server returns an error, revert the optimistic update
                        setTasks(originalTasks);
                        return res.json().then(err => { throw new Error(err.message || 'Server update failed.') });
                    }
                    return res.json();
                })
                .then(data => {
                    if (data.status !== 'success') {
                        // Handle logical errors from the server and revert
                        setTasks(originalTasks);
                        throw new Error(data.message || 'An unknown error occurred.');
                    }
                    setNotification({ message: 'Task updated successfully!', type: 'success' });
                })
                .catch(err => {
                    setTasks(originalTasks);
                    setAppError('Save error: ' + err.message);
                });
        }, [tasks, selectedProject, loggedInUser]);


        const saveDataToServer = useCallback((tasksToSave, successMessage = 'Saved successfully') => {
            let updatedTasks = recalculateParentProgress(tasksToSave);
            const payload = { tasks: updatedTasks, user_email: loggedInUser.email };
            makeAuthenticatedRequest(`/api/save?project=${encodeURIComponent(selectedProject)}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
                .then(async res => {
                    const data = await res.json();
                    if (handleAPIError(res, data)) return;
                    return data;
                })
                .then(data => {
                    if (data.status === 'success') {
                        setTasks(updatedTasks);
                        setNotification({ message: successMessage, type: 'success' });
                    } else {
                        throw new Error(data.message || 'Save failed');
                    }
                })
                .catch(err => setAppError('Save error: ' + err.message));
        }, [selectedProject, loggedInUser]);

        const handleConfirmAddTask = useCallback((newTaskData) => {
            if (!addTaskContext) return;

            const payload = {
                newTask: newTaskData,
                context: addTaskContext,
                user_email: loggedInUser.email
            };

            makeAuthenticatedRequest(`/api/add_task?project=${encodeURIComponent(selectedProject)}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
                .then(async res => {
                    const data = await res.json();
                    if (handleAPIError(res, data)) return;
                    if (!res.ok) {
                        throw new Error(data.message || 'Failed to add task.');
                    }
                    return data;
                })
                .then(data => {
                    if (data.status === 'success') {
                        setTasks(normalizeTasks(data.updatedTasks));
                        setNotification({ message: 'New task added successfully.', type: 'success' });
                    } else {
                        throw new Error(data.message);
                    }
                })
                .catch(err => setAppError('Add task error: ' + err.message))
                .finally(() => {
                    setAddTaskContext(null); // Close the modal regardless of outcome
                });
        }, [selectedProject, addTaskContext, loggedInUser]);

        const handleDeleteTask = useCallback((taskId) => {
            if (!window.confirm("Are you sure you want to delete this task and all its subtasks? This action is irreversible.")) return;

            const payload = {
                taskId: taskId,
                user_email: loggedInUser.email
            };

            makeAuthenticatedRequest(`/api/delete_task?project=${encodeURIComponent(selectedProject)}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
                .then(async res => {
                    const data = await res.json();
                    if (handleAPIError(res, data)) return;
                    if (!res.ok) {
                        throw new Error(data.message || 'Failed to delete task.');
                    }
                    return data;
                })
                .then(data => {
                    if (data.status === 'success') {
                        setTasks(normalizeTasks(data.updatedTasks));
                        setNotification({ message: 'Task deleted successfully.', type: 'info' });
                    } else {
                        throw new Error(data.message);
                    }
                })
                .catch(err => setAppError('Delete task error: ' + err.message));
        }, [selectedProject, loggedInUser]);

        const handleAddProject = (name, code) => {
            // Proactive check for project limits
            const usage = window.latestUsageStats;
            if (usage && usage.at_limit && usage.at_limit.projects) {
                alert('You have reached the maximum number of projects allowed by your plan.');
                if (typeof window.refreshUsageStats === 'function') window.refreshUsageStats();
                return;
            }
            makeAuthenticatedRequest('/api/projects', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ project_name: name, client_access_code: code })
            })
                .then(async res => {
                    const data = await res.json();
                    if (handleAPIError(res, data)) return;
                    return data;
                })
                .then(data => {
                    if (data.status === 'success') {
                        setProjects(prev => [...prev, data.project]);
                        setSelectedProject(name);
                        setNotification({ message: 'Project added!', type: 'success' });
                    } else { throw new Error(data.message); }
                })
                .catch(err => setAppError(err.message));
        };

        const handleCSVImportSuccess = (rowCount) => {
            setNotification({ message: `${rowCount} tasks imported successfully.`, type: 'success' });
            loadInitialData(selectedProject);
        };

        const handleExport = (format) => {
            const getTasksForExport = () => {
                if (loggedInUser.userType === 'client' || currentView === 'client') {
                    return clientViewTasks;
                }
                return tasks;
            };

            const tasksToExport = getTasksForExport();
            const viewLabel = (loggedInUser.userType === 'client' || currentView === 'client') ? ' (Client View)' : '';
            const viewLabelForFilename = (loggedInUser.userType === 'client' || currentView === 'client') ? '_client_view' : '';

            if (format === 'csv') {
                const csvContent = generateCSV(tasksToExport);
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement("a");
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", `${selectedProject}_tasks.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } else if (format === 'pdf') {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                doc.setFontSize(18); doc.text(APP_TITLE, 14, 22);
                doc.setFontSize(11); doc.setTextColor(100); doc.text(APP_SUBTITLE, 14, 28);
                doc.setFontSize(10); doc.setTextColor(150); doc.text(`Project: ${selectedProject}${viewLabel}`, 14, 34);

                const flattenedTasksForExport = [];
                const flatten = (tasksToFlatten) => {
                    tasksToFlatten.forEach(task => {
                        flattenedTasksForExport.push(task);
                        if (task.subtasks) flatten(task.subtasks);
                    });
                };
                flatten(tasksToExport);

                const head = [['WBS', 'Task Name', 'Planned Start', 'Planned End', 'Status', 'Progress (%)', 'Critical']];
                const body = flattenedTasksForExport.map(task => [task.wbs, task.taskName, formatDateForDisplay(task.plannedStartDate), formatDateForDisplay(task.plannedEndDate), task.status, task.progress || 0, task.isCritical ? 'Yes' : 'No']);

                doc.autoTable({ startY: 40, head, body, theme: 'grid' });
                doc.save(`${selectedProject}_schedule${viewLabelForFilename}.pdf`);
            } else if (format === 'gantt') {
                const ganttElement = document.getElementById('gantt-chart-render-area');
                if (!ganttElement) {
                    setAppError("Gantt chart not found. Please ensure the chart is visible before exporting.");
                    return;
                }
                if (!window.html2canvas) {
                    setAppError("Export library not loaded. Please refresh the page and try again.");
                    return;
                }
                if (!tasksToExport || tasksToExport.length === 0) {
                    setAppError("No tasks available for Gantt export.");
                    return;
                }

                const scrollWidth = ganttElement.scrollWidth;
                const scrollHeight = ganttElement.scrollHeight;

                // You can keep this check as a preliminary guard
                const MAX_CANVAS_AREA = 16384 * 16384;
                if (scrollWidth * scrollHeight > MAX_CANVAS_AREA) {
                    setAppError("The Gantt chart is too large to export as a single image. Please apply filters to reduce the number of tasks.");
                    return;
                }

                setNotification({ message: 'Generating high-quality Gantt chart image...', type: 'info' });

                window.html2canvas(ganttElement, {
                    backgroundColor: '#ffffff',
                    width: scrollWidth,
                    height: scrollHeight,
                    windowWidth: scrollWidth,
                    windowHeight: scrollHeight,
                    useCORS: true,
                    scale: 2
                }).then(canvas => {
                    const image = canvas.toDataURL('image/png', 1.0);

                    // --- Validate the generated image data ---
                    if (!image || image.length < 100 || image === 'data:,') {
                        setAppError("The Gantt chart is too large to export as a single image. Please apply filters to reduce the number of tasks.");
                        setNotification(null); // Clear the "generating" message
                        return;
                    }

                    const link = document.createElement('a');
                    link.download = `${selectedProject}_gantt_chart${viewLabelForFilename}.png`;
                    link.href = image;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    setNotification({ message: 'High-quality Gantt chart exported successfully!', type: 'success' });
                }).catch(err => {
                    console.error("Failed to capture Gantt chart:", err);
                    setAppError("Could not generate Gantt chart image. " + err.message);
                });
            }
        };

        const handleLogout = () => {
            const accessToken = localStorage.getItem('access_token');
            
            // Call logout API to revoke token on server
            if (accessToken) {
                fetch('/api/logout', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + accessToken
                    }
                }).catch(err => console.error('Logout API error:', err));
            }
            
            // Clear all authentication data from localStorage
            localStorage.removeItem('access_token');
            localStorage.removeItem('refresh_token');
            localStorage.removeItem('user_data');
            // Clean up legacy auth format if present
            localStorage.removeItem('aiProjectControlTowerAuth_v2');
            sessionStorage.removeItem('trial_banner_dismissed');
            sessionStorage.removeItem('trial_banner_dismissed_at');
            
            window.location.href = '/';
        };

        const handleToggleExpansion = (taskId) => {
            const toggle = (taskList) => {
                return taskList.map(t => {
                    if (t.id === taskId) {
                        return { ...t, isExpanded: !t.isExpanded };
                    }
                    if (t.subtasks && t.subtasks.length > 0) {
                        return { ...t, subtasks: toggle(t.subtasks) };
                    }
                    return t;
                });
            };
            setTasks(toggle(tasks));
        };

        const handleToggleAllExpansion = useCallback(() => {
            const nextExpansionState = !areAllExpanded;
            const toggleRecursively = (taskList) => {
                return taskList.map(t => ({
                    ...t,
                    isExpanded: nextExpansionState,
                    subtasks: t.subtasks ? toggleRecursively(t.subtasks) : []
                }));
            };
            setTasks(toggleRecursively(tasks));
            setAreAllExpanded(nextExpansionState);
        }, [tasks, areAllExpanded]);

        const handleToggleAllClientDeliverables = useCallback((shouldSelectAll) => {
            // Optimistically update the UI for a responsive feel
            const toggleRecursively = (taskList) => {
                return taskList.map(t => ({
                    ...t,
                    isClientDeliverable: shouldSelectAll,
                    subtasks: t.subtasks ? toggleRecursively(t.subtasks) : []
                }));
            };
            const optimisticallyUpdatedTasks = toggleRecursively(tasks);
            setTasks(optimisticallyUpdatedTasks);

            const payload = {
                should_select_all: shouldSelectAll,
                user_email: loggedInUser.email
            };

            // Call the new, efficient endpoint
            makeAuthenticatedRequest(`/api/toggle_all_client_deliverables?project=${encodeURIComponent(selectedProject)}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
                .then(res => {
                    if (!res.ok) {
                        // If the server fails, revert the optimistic update
                        setTasks(tasks);
                        return res.json().then(err => { throw new Error(err.message || 'Server update failed.') });
                    }
                    return res.json();
                })
                .then(data => {
                    if (data.status === 'success') {
                        const message = shouldSelectAll ? 'All tasks marked for client view.' : 'All tasks removed from client view.';
                        setNotification({ message: message, type: 'success' });
                        // Optionally, you can re-fetch data here to ensure perfect sync, 
                        // but the optimistic update should suffice.
                        // loadInitialData(selectedProject);
                    } else {
                        throw new Error(data.message);
                    }
                })
                .catch(err => {
                    setTasks(tasks); // Revert on any failure
                    setAppError('Bulk update error: ' + err.message);
                });
        }, [tasks, selectedProject, loggedInUser, saveDataToServer]);

        const handleNavigate = useCallback((page) => {
            if (page === 'charts') {
                window.location.href = `/charts?project=${encodeURIComponent(selectedProject)}`;
            }
            setIsSidebarOpen(false);
        }, [selectedProject]);

        const clientViewTasks = useMemo(() => {
            if (!tasks) return [];
            const filterDeliverables = (taskList) => {
                if (!taskList) return [];
                return taskList
                    .map(task => ({ ...task, subtasks: filterDeliverables(task.subtasks) }))
                    .filter(task => task.isClientDeliverable || (task.subtasks && task.subtasks.length > 0));
            };
            return filterDeliverables(tasks);
        }, [tasks]);

        const filteredAndSortedTasks = useMemo(() => {
            if (!loggedInUser) return [];

            let baseTasks = (currentView === 'client' && loggedInUser.userType !== 'client') ? clientViewTasks : tasks;

            if (loggedInUser.userType === 'client') {
                baseTasks = clientViewTasks;
            }

            let filtered = baseTasks;

            if (searchTerm || startDateFilter || endDateFilter) {
                const searchFilter = (taskList) => {
                    if (!taskList) return [];
                    return taskList.map(task => {
                        const hasVisibleSubtasks = task.subtasks && task.subtasks.length > 0;
                        const subtasks = hasVisibleSubtasks ? searchFilter(task.subtasks) : [];

                        const matchesSearch = searchTerm ? (task.taskName || '').toLowerCase().includes(searchTerm.toLowerCase()) || (task.wbs || '').toLowerCase().includes(searchTerm.toLowerCase()) : true;

                        const matchesStartDate = startDateFilter && task.plannedStartDate ? task.plannedStartDate >= startDateFilter : true;
                        const matchesEndDate = endDateFilter && task.plannedEndDate ? task.plannedEndDate <= endDateFilter : true;

                        const selfMatches = matchesSearch && matchesStartDate && matchesEndDate;

                        if (selfMatches || subtasks.length > 0) {
                            return { ...task, subtasks };
                        }
                        return null;
                    }).filter(Boolean);
                }
                filtered = searchFilter(filtered);
            }

            const sortRecursively = (taskList) => {
                if (!taskList) return;
                taskList.sort((a, b) => {
                    const fieldA = a[sortBy.field], fieldB = b[sortBy.field]; let comparison = 0;
                    if (sortBy.field === 'wbs') {
                        comparison = a.wbs.localeCompare(b.wbs, undefined, { numeric: true, sensitivity: 'base' });
                    } else {
                        if (fieldA > fieldB) comparison = 1; else if (fieldA < fieldB) comparison = -1;
                    }
                    return sortBy.order === 'asc' ? comparison : comparison * -1;
                });
                taskList.forEach(task => { if (task.subtasks) sortRecursively(task.subtasks); });
            };

            const sorted = [...filtered];
            sortRecursively(sorted);
            return sorted;
        }, [tasks, clientViewTasks, currentView, loggedInUser, searchTerm, startDateFilter, endDateFilter, sortBy]);

        const handleSort = (field) => { setSortBy(prev => ({ field, order: prev.field === field && prev.order === 'asc' ? 'desc' : 'asc' })); };

        useEffect(() => {
            if (appError) { const timer = setTimeout(() => setAppError(null), 7000); return () => clearTimeout(timer); }
        }, [appError]);

        const unreadNotifications = useMemo(() => {
            if (!loggedInUser) return [];
            const notifications = new Map(); // Use a Map to prevent duplicate tasks in the list

            const findUnread = (taskList) => {
                if (!taskList) return;
                taskList.forEach(task => {
                    if (task.clientComments && task.clientComments.length > 0) {
                        // For Client: Check if ANY comment is un-replied to
                        if (loggedInUser.userType === 'client') {
                            const hasPending = task.clientComments.some(c => !c.clientStatus);
                            if (hasPending && !notifications.has(task.id)) {
                                const latestPending = [...task.clientComments].reverse().find(c => !c.clientStatus);
                                let notificationText = "New communication received.";
                                const type = latestPending.communicationType;
                                if (type === 'Information') { notificationText = "Information regarding project has been delivered."; }
                                else if (type === 'Review') { notificationText = "A comment for your review has been received."; }
                                else if (type === 'Approval') { notificationText = "Something needs your approval."; }
                                notifications.set(task.id, { ...task, notificationText });
                            }
                        }
                        // For Admin: Check if ANY comment has an unread client response
                        else if (loggedInUser.userType !== 'client') {
                            const hasUnread = task.clientComments.some(c => c.clientStatus && c.adminSeen === false);
                            if (hasUnread && !notifications.has(task.id)) {
                                notifications.set(task.id, { ...task, notificationText: "Client has responded to a communication." });
                            }
                        }
                    }
                    if (task.subtasks) findUnread(task.subtasks);
                });
            };
            findUnread(tasks);
            return Array.from(notifications.values());
        }, [tasks, loggedInUser]);

        // Moved icon definitions and other functions before the conditional return
        const scrollToWbs = (id) => {
            const element = document.getElementById(id);
            if (element) {
                element.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        };

        const OverallIcon = () => React.createElement("svg", { className: "oepc-icon", fill: "none", viewBox: "0 0 24 24", strokeWidth: "2.5", stroke: "#157dc2" },
            React.createElement("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M3.75 6A2.25 2.25 0 016 3.75h2.25A2.25 2.25 0 0110.5 6v2.25a2.25 2.25 0 01-2.25 2.25H6a2.25 2.25 0 01-2.25-2.25V6zM3.75 15.75A2.25 2.25 0 016 13.5h2.25a2.25 2.25 0 012.25 2.25V18a2.25 2.25 0 01-2.25 2.25H6A2.25 2.25 0 013.75 18v-2.25zM13.5 6a2.25 2.25 0 012.25-2.25H18A2.25 2.25 0 0120.25 6v2.25A2.25 2.25 0 0118 10.5h-2.25a2.25 2.25 0 01-2.25-2.25V6zM13.5 15.75a2.25 2.25 0 012.25-2.25H18a2.25 2.25 0 012.25 2.25V18A2.25 2.25 0 0118 20.25h-2.25A2.25 2.25 0 0113.5 18v-2.25z" })
        );

        const EngineeringIcon = () => React.createElement("img", { src: "static/Engineering.png", alt: "Engineering", className: "oepc-icon" });
        const ProcurementIcon = () => React.createElement("img", { src: "static/Procurement.png", alt: "Procurement", className: "oepc-icon" });
        const ConstructionIcon = () => React.createElement("img", { src: "static/Construction.png", alt: "Construction", className: "oepc-icon" });

        const NotificationIcon = () => (
            React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className: "feather feather-bell" },
                React.createElement("path", { d: "M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9" }),
                React.createElement("path", { d: "M13.73 21a2 2 0 0 1-3.46 0" })
            )
        );

        if (isLoading && !loggedInUser) {
            return React.createElement(LoadingSpinner, { message: "Authenticating..." });
        }


        return React.createElement("div", { className: `min-h-screen bg-slate-100 p-2 sm:p-4 md:p-8 font-sans ${trialStatus && trialStatus.is_trial && (!isTrialBannerDismissed || trialStatus.is_expired) ? 'pt-20' : ''}` },
            // Trial Countdown Banner
            loggedInUser && loggedInUser.role !== 'super_admin' && loggedInUser.userType !== 'client' && trialStatus && 
                React.createElement(TrialCountdownBanner, {
                    trialStatus: trialStatus,
                    onUpgradeClick: handleTrialUpgrade,
                    onDismiss: handleDismissTrialBanner,
                    isDismissed: isTrialBannerDismissed
                }),
            React.createElement("div", { className: "oepc-nav-bar-right" }, // Changed class name here
                // Overall
                React.createElement("a", { href: "#", onClick: (e) => { e.preventDefault(); scrollToWbs("wbs-1"); }, className: "oepc-nav-link" },
                    React.createElement(OverallIcon),
                    React.createElement("span", { className: "tooltip" }, "Overall")
                ),
                // Engineering
                React.createElement("a", { href: "#", onClick: (e) => { e.preventDefault(); scrollToWbs("wbs-1.2"); }, className: "oepc-nav-link" },
                    React.createElement(EngineeringIcon),
                    React.createElement("span", { className: "tooltip" }, "Engineering")
                ),
                // Procurement
                React.createElement("a", { href: "#", onClick: (e) => { e.preventDefault(); scrollToWbs("wbs-1.3"); }, className: "oepc-nav-link" },
                    React.createElement(ProcurementIcon),
                    React.createElement("span", { className: "tooltip" }, "Procurement")
                ),
                // Construction
                React.createElement("a", { href: "#", onClick: (e) => { e.preventDefault(); scrollToWbs("wbs-1.4"); }, className: "oepc-nav-link" },
                    React.createElement(ConstructionIcon),
                    React.createElement("span", { className: "tooltip" }, "Construction")
                )
            ),

                React.createElement("div", {},
                React.createElement("div", { className: `fixed inset-0 bg-black bg-opacity-50 z-40 ${isSidebarOpen ? 'block' : 'hidden'}`, onClick: () => setIsSidebarOpen(false) }),
                React.createElement("div", { className: `fixed top-0 left-0 h-full bg-slate-800 text-white w-64 p-4 z-50 transform transition-transform ${isSidebarOpen ? 'translate-x-0' : '-translate-x-full'}` },
                    React.createElement('h2', { className: 'text-2xl font-bold mb-8 text-sky-400' }, 'PROTON'),
                    React.createElement('ul', { className: 'space-y-2' },
                        React.createElement('li', null, React.createElement('button', { onClick: () => handleNavigate('charts'), className: 'w-full text-left flex items-center gap-3 px-3 py-2 rounded-md hover:bg-slate-700' }, React.createElement(BarChartIcon, null), 'Charts'))
                    ),
                    (loggedInUser && (loggedInUser.role === 'super_admin' || loggedInUser.role === 'org_admin')) && React.createElement(UsageStatsWidget, { role: loggedInUser.role }),
                    (loggedInUser && (loggedInUser.role === 'super_admin' || loggedInUser.role === 'org_admin')) && React.createElement('div', { className: 'mt-4' },
                        React.createElement('button', { onClick: () => setShowSubscriptionManagement(true), className: 'w-full text-left flex items-center gap-3 px-3 py-2 rounded-md hover:bg-slate-700 text-white' },
                            React.createElement('span', { className: 'w-5 h-5' }, '💳'), 'Manage Subscription'
                        )
                    )
                )
            ),
            React.createElement("header", { className: "mb-6 p-4 bg-white shadow-md rounded-lg" },
                React.createElement("div", { className: "flex flex-wrap items-center justify-between gap-4" },
                    React.createElement("div", { className: "flex items-center space-x-3" },
                        React.createElement("button", { onClick: () => setIsSidebarOpen(true), className: "p-2 rounded-md hover:bg-slate-100 lg:hidden" }, React.createElement(MenuIcon, { size: 24, className: "text-slate-600" })),
                        React.createElement("img", { src: '/static/logo.png', alt: "App Logo", className: "h-10 w-auto", crossOrigin: "anonymous" }),
                        React.createElement("div", null,
                            React.createElement("span", { className: "text-xl sm:text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-sky-600 to-blue-700" }, APP_TITLE),
                            React.createElement("span", { className: "text-base bg-clip-text text-slate-500 italic" }, APP_TITLE2),
                            loggedInUser && React.createElement("div", { className: "mt-2 flex items-center space-x-2" },
                                React.createElement("span", { className: "text-sm text-slate-600" }, loggedInUser.email),
                                getRoleBadge(loggedInUser.role)
                            ),
                            React.createElement("h1", { className: "text-sm font-bold text-slate-500" }, APP_SUBTITLE)
                        )
                    ),
                    React.createElement("div", { className: "hidden lg:flex items-center gap-4" },
                        React.createElement("nav", { className: "flex items-center gap-1" },
                            React.createElement("a", { href: `/charts?project=${encodeURIComponent(selectedProject)}`, className: 'px-4 py-2 text-sm font-semibold rounded-lg text-slate-600 hover:bg-slate-100' }, "Charts")
                        ),
                        React.createElement("div", { className: "h-6 w-px bg-slate-200" }),
                        React.createElement("div", { className: "relative" },
                            React.createElement("button", { onClick: () => setShowNotificationDropdown(!showNotificationDropdown), className: "p-2 rounded-full hover:bg-slate-100" },
                                React.createElement(NotificationIcon, null),
                                unreadNotifications.length > 0 && React.createElement("span", { className: "absolute -top-1 -right-1 block h-3 w-3 rounded-full bg-red-500 ring-2 ring-white" })
                            ),
                            showNotificationDropdown && React.createElement("div", { className: "absolute right-0 mt-2 w-80 bg-white rounded-lg shadow-xl z-20" },
                                React.createElement("div", { className: "p-4 font-bold border-b" }, "Notifications"),
                                React.createElement("div", { className: "max-h-96 overflow-y-auto" },
                                    unreadNotifications.length > 0 ?
                                        unreadNotifications.map(task => (
                                            React.createElement("div", { key: task.id, onClick: () => { openClientCommModal(task); setShowNotificationDropdown(false); }, className: "p-4 border-b hover:bg-slate-50 cursor-pointer" },
                                                React.createElement("p", { className: "font-semibold" }, task.taskName),
                                                React.createElement("p", { className: "text-sm text-slate-500" }, task.notificationText)
                                            )
                                        )) :
                                        React.createElement("p", { className: "p-4 text-slate-500" }, "No new notifications.")
                                )
                            )
                        ),
                        React.createElement("div", { className: "flex items-center gap-2" },
                            (loggedInUser && loggedInUser.role === 'super_admin') && React.createElement("button", { onClick: () => { window.location.href = '/superadmin'; }, className: "px-4 py-2 text-sm font-medium bg-gradient-to-r from-purple-600 to-blue-600 text-white hover:from-purple-700 hover:to-blue-700 border border-slate-200 rounded-lg flex items-center" }, React.createElement(BarChartIcon, { size: 16, className: "mr-2" }), "SuperAdmin Dashboard"),
                            canManageUsers(loggedInUser.role) && React.createElement("button", { onClick: () => setShowUserManagementModal(true), className: "px-4 py-2 text-sm font-medium text-slate-700 bg-slate-100 hover:bg-slate-200 border border-slate-200 rounded-lg flex items-center btn-add-user manage-users-btn" }, React.createElement(UserCog, { size: 16, className: "mr-2" }), "Manage Users"),
                            canViewActivityLogs(loggedInUser.role) && React.createElement("button", { onClick: () => setShowActivityLogModal(true), className: "px-4 py-2 text-sm font-medium text-slate-700 bg-slate-100 hover:bg-slate-200 border border-slate-200 rounded-lg flex items-center activity-log" }, React.createElement(HistoryIcon, { size: 16, className: "mr-2" }), "Activity Log"),
                            React.createElement("button", { onClick: handleShowTutorial, className: "px-4 py-2 text-sm font-medium text-slate-700 bg-slate-100 hover:bg-slate-200 border border-slate-200 rounded-lg flex items-center" }, React.createElement("span", { className: "mr-2" }, "❓"), "Show Tutorial"),
                            React.createElement("button", { onClick: handleLogout, className: "px-4 py-2 text-sm font-medium text-slate-700 bg-slate-100 hover:bg-slate-200 border border-slate-200 rounded-lg flex items-center" }, React.createElement(LogOutIcon, { size: 16, className: "mr-2" }), "Logout")
                        )
                    )
                ),
                loggedInUser && loggedInUser.userType !== 'client' && React.createElement("div", { className: "mt-4 flex flex-col sm:flex-col justify-between items-center gap-4" },
                    React.createElement("div", { className: "flex items-center gap-2" },
                        React.createElement("select", { value: selectedProject, onChange: e => setSelectedProject(e.target.value), className: "w-full p-2 bg-slate-50 text-slate-700 rounded-md border border-slate-300 focus:ring-2 focus:ring-sky-500 outline-none" },
                            projects.length === 0 && React.createElement("option", null, "No projects available"),
                            projects.map(p => React.createElement("option", { key: p.name, value: p.name }, p.name))
                        ),
                        canManageProjects(loggedInUser.role) && React.createElement("button", { 
                            onClick: () => setShowAddProjectModal(true), 
                            disabled: isTrialExpired,
                            title: isTrialExpired ? 'Trial expired. Upgrade to continue.' : undefined,
                            className: `p-2 text-sm font-medium text-white bg-green-500 hover:bg-green-600 rounded-lg flex items-center justify-center btn-add-project ${isTrialExpired ? 'opacity-50 cursor-not-allowed' : ''}` 
                        }, React.createElement(PlusCircle, { size: 16 }))
                    ),
                    React.createElement("div", { className: "flex items-center gap-2 bg-slate-100 rounded-lg p-1" },
                        React.createElement("button", { onClick: () => setCurrentView('admin'), className: `px-3 py-1.5 text-sm font-semibold rounded-md transition-colors ${currentView === 'admin' ? 'bg-white shadow text-sky-600' : 'text-slate-600 hover:bg-slate-200'}` }, "Admin View"),
                        React.createElement("button", { onClick: () => setCurrentView('client'), className: `px-3 py-1.5 text-sm font-semibold rounded-md transition-colors flex items-center ${currentView === 'client' ? 'bg-white shadow text-sky-600' : 'text-slate-600 hover:bg-slate-200'}` }, React.createElement(EyeIcon, { size: 16, className: "mr-1.5" }), "Client View")
                    )
                ),
                loggedInUser && React.createElement("div", { className: "mb-4 p-4 bg-blue-50 border border-blue-200 rounded-lg" },
                    React.createElement("p", { className: "text-sm text-blue-700" }, getWelcomeMessage(loggedInUser.role))
                ),
                dashboardData && dashboardData.next_critical_activity && (
                    React.createElement("div", { className: "mt-4 p-3 bg-red-50 border-l-4 border-red-400 text-red-800 text-sm" },
                        React.createElement("strong", null, "Next Critical Activity: "),
                        `${dashboardData.next_critical_activity.wbs} - ${dashboardData.next_critical_activity.taskName}`
                    )
                )
            ),
            notification && React.createElement(NotificationToast, { message: notification.message, type: notification.type, onDismiss: () => setNotification(null) }),
            appError && React.createElement("div", { className: "mb-4 p-3 bg-red-100 border border-red-300 text-red-700 rounded-lg text-sm", role: "alert" }, React.createElement("strong", null, "Error: "), appError),
            React.createElement('div', null,
                canApproveAdmins(loggedInUser.role) && React.createElement(ApprovalDashboard, { pendingAdmins: pendingAdmins, onApprove: (email) => setPendingAdmins(prev => prev.filter(p => p.email !== email)), onReject: (email) => setPendingAdmins(prev => prev.filter(p => p.email !== email)), setNotification, setAppError }),
                tasks.length > 0 && !isLoading && React.createElement(OverallProgress, { tasks: tasks, selectedProject: selectedProject }),
                React.createElement("div", { className: "mb-4 p-4 bg-white shadow-md rounded-lg flex flex-col sm:flex-row sm:items-center gap-4 flex-wrap" },
                    React.createElement("input", { type: "text", placeholder: "Search Tasks...", value: searchTerm, onChange: e => setSearchTerm(e.target.value), className: "w-full sm:w-auto flex-grow p-2 border border-slate-300 rounded-lg" }),
                    React.createElement("input", { type: "date", value: startDateFilter, onChange: e => setStartDateFilter(e.target.value), className: "w-full sm:w-auto p-2 border border-slate-300 rounded-lg" }),
                    React.createElement("input", { type: "date", value: endDateFilter, onChange: e => setEndDateFilter(e.target.value), className: "w-full sm:w-auto p-2 border border-slate-300 rounded-lg" }),

                    loggedInUser && loggedInUser.userType !== 'client' && React.createElement(React.Fragment, null,
                        canManageProjects(loggedInUser.role) && React.createElement("button", { 
                            onClick: () => setShowCSVImportModal(true), 
                            disabled: isTrialExpired,
                            title: isTrialExpired ? 'Trial expired. Upgrade to continue.' : undefined,
                            className: `px-4 py-2 text-sm font-semibold rounded-lg bg-gradient-to-r from-sky-500 to-blue-600 text-white hover:from-sky-600 hover:to-blue-700 shadow-lg transition-all duration-300 flex items-center justify-center gap-2 import-csv-btn ${isTrialExpired ? 'opacity-50 cursor-not-allowed' : ''}` 
                        }, React.createElement(UploadCloud, { size: 18, className: "mr-2" }), "Import CSV"),
                        React.createElement("button", { 
                            onClick: () => handleExport('csv'), 
                            disabled: isTrialExpired,
                            title: isTrialExpired ? 'Trial expired. Upgrade to continue.' : undefined,
                            className: `px-4 py-2 text-sm font-semibold rounded-lg bg-gradient-to-r from-green-400 to-green-600 text-white shadow-lg hover:from-green-500 hover:to-green-700 transition-all duration-300 flex items-center justify-center gap-2 ${isTrialExpired ? 'opacity-50 cursor-not-allowed' : ''}` 
                        }, React.createElement(DownloadCloud, { size: 18, className: "mr-2" }), "Export CSV")
                    ),

                    React.createElement("button", { 
                        onClick: () => handleExport('pdf'), 
                        disabled: isTrialExpired,
                        title: isTrialExpired ? 'Trial expired. Upgrade to continue.' : undefined,
                        className: `px-4 py-2 text-sm font-semibold rounded-lg bg-gradient-to-r from-purple-400 to-purple-600 text-white shadow-lg hover:from-purple-500 hover:to-purple-700 transition-all duration-300 flex items-center justify-center gap-2 ${isTrialExpired ? 'opacity-50 cursor-not-allowed' : ''}` 
                    }, React.createElement(FileText, { size: 18, className: "mr-2" }), "Export PDF"),
                    React.createElement("button", { 
                        onClick: () => handleExport('gantt'), 
                        disabled: isTrialExpired,
                        title: isTrialExpired ? 'Trial expired. Upgrade to continue.' : undefined,
                        className: `px-4 py-2 text-sm font-semibold rounded-lg bg-gradient-to-r from-pink-400 to-pink-600 text-white shadow-lg hover:from-pink-500 hover:to-pink-700 transition-all duration-300 flex items-center justify-center gap-2 export-gantt gantt-toggle ${isTrialExpired ? 'opacity-50 cursor-not-allowed' : ''}` 
                    }, React.createElement(Image, { size: 18, className: "mr-2" }), "Export Gantt")
                ),
                isLoading ? React.createElement(LoadingSpinner, { message: loggedInUser && loggedInUser.userType === 'client' ? "Loading Project Data..." : "Loading Tasks..." }) : (filteredAndSortedTasks.length > 0 ?
                    React.createElement(TaskTable, {
                        tasks: filteredAndSortedTasks,
                        viewType: currentView,
                        loggedInUserType: loggedInUser.userType,
                        sortBy: sortBy,
                        onSort: handleSort,
                        areAllExpanded: areAllExpanded,
                        onToggleAllExpansion: handleToggleAllExpansion,
                        onUpdateTask: handleUpdateTask,
                        onAddTask: (task) => openAddTaskModal(task, 'sibling'),
                        onAddSubTask: (task) => openAddTaskModal(task, 'child'),
                        onDeleteTask: handleDeleteTask,
                        onEditTask: openEditModal,
                        onAIUpdate: openAIModal,
                        onShowNotes: openNotesModal,
                        onShowDetails: openDetailsModal,
                        onClientComm: openClientCommModal,
                        onToggleClientDeliverable: (task, isChecked) => handleUpdateTask(task.id, { isClientDeliverable: isChecked }),
                        onToggleExpansion: handleToggleExpansion,
                        onToggleAllClientDeliverables: handleToggleAllClientDeliverables,
                        hasMoreTasks: hasMoreTasks,
                        isLoadingMore: isLoadingMore,
                        loadMoreTasks: loadMoreTasks,
                        isTrialExpired: isTrialExpired
                    }) :
                    React.createElement("div", { className: "text-center py-10 bg-white shadow rounded-lg" }, "No tasks found.")
                ),
                ((currentView === 'admin' && loggedInUser.userType !== 'client') || currentView === 'client') && !isLoading && filteredAndSortedTasks.length > 0 && React.createElement(GanttChart, { tasks: filteredAndSortedTasks })
            ),
            showActivityLogModal && React.createElement(ActivityLogModal, { onClose: () => setShowActivityLogModal(false) }),
            showCSVImportModal && React.createElement(CSVImportModal, { 
                onClose: () => setShowCSVImportModal(false), 
                onImport: handleCSVImportSuccess, 
                selectedProject: selectedProject,
                loggedInUser: loggedInUser 
            }),
            showDetailsModal && selectedTask && React.createElement(TaskDetailsModal, { task: selectedTask, onClose: () => setShowDetailsModal(false), loggedInUserType: loggedInUser.userType }),
            showEditModal && selectedTask && React.createElement(EditTaskModal, {
                task: selectedTask,
                onClose: () => setShowEditModal(false),
                onSave: (updatedData) => {
                    handleUpdateTask(selectedTask.id, updatedData);
                    setShowEditModal(false);
                },
                isTrialExpired: isTrialExpired
            }),
            showAddProjectModal && React.createElement(AddProjectModal, { onClose: () => setShowAddProjectModal(false), onAdd: (name, code) => { handleAddProject(name, code); setShowAddProjectModal(false); } }),
            showAddTaskModal && addTaskContext && React.createElement(AddTaskModal, { mode: addTaskContext.mode, onClose: () => setAddTaskContext(null), onAdd: handleConfirmAddTask }),
            showAIModal && selectedTask && React.createElement(AIUpdateModal, {
                task: selectedTask,
                allTasks: tasks,
                loggedInUserType: loggedInUser.userType,
                onClose: () => setShowAIModal(false),
                setAppError: setAppError,
                onApplySuggestion: (taskId, suggestedData) => {
                    handleUpdateTask(taskId, suggestedData);
                    setShowAIModal(false);
                },
            }),
            showNotesModal && selectedTask && React.createElement(NotesModal, {
                task: selectedTask,
                loggedInUser: loggedInUser,
                onClose: () => setShowNotesModal(false),
                onAddNote: (taskId, noteText) => {
                    const taskToUpdate = findTaskById(tasks, taskId);
                    if (taskToUpdate) {
                        const newNote = {
                            text: noteText,
                            timestamp: new Date().toISOString(),
                            source: loggedInUser.name
                        };
                        const updatedNotes = [...(taskToUpdate.notes || []), newNote];
                        handleUpdateTask(taskId, { notes: updatedNotes });
                    }
                    setShowNotesModal(false);
                }
            }),
            showClientCommModal && selectedTask && React.createElement(ClientCommunicationModal, {
                task: selectedTask,
                loggedInUser: loggedInUser,
                selectedProject: selectedProject, // Pass selectedProject as a prop
                onClose: () => setShowClientCommModal(false),
                onAdminAddComment: (taskId, comment, type, attachmentPaths) => { // Note: attachmentPaths is an array
                    const taskToUpdate = findTaskById(tasks, taskId);
                    if (taskToUpdate) {
                        const newComment = {
                            id: generateUUID(),
                            adminName: loggedInUser.name,
                            adminTimestamp: new Date().toISOString(),
                            adminComment: comment,
                            communicationType: type,
                            attachments: attachmentPaths || [] // Save as an array
                        };
                        const updatedComments = [...(taskToUpdate.clientComments || []), newComment];
                        handleUpdateTask(taskId, { clientComments: updatedComments });
                    }
                    setShowClientCommModal(false);
                },
                onClientRespond: (taskId, commentId, status, commentText, clientAttachmentPaths = []) => {
                    const taskToUpdate = findTaskById(tasks, taskId);
                    if (taskToUpdate) {
                        const updatedComments = (taskToUpdate.clientComments || []).map(cc =>
                            cc.id === commentId
                                ? {
                                    ...cc,
                                    clientStatus: status,
                                    clientComment: commentText,
                                    clientResponseTimestamp: new Date().toISOString(),
                                    clientAttachments: clientAttachmentPaths
                                }
                                : cc
                        );
                        handleUpdateTask(taskId, { clientComments: updatedComments });
                    }
                    setShowClientCommModal(false);
                }
            }),
            showUserManagementModal && React.createElement(UserManagementModal, {
                onClose: () => setShowUserManagementModal(false),
                loggedInUser: loggedInUser,
                onUserCreated: (user) => {
                    setNotification({ message: 'User created successfully', type: 'success' });
                },
                onUserUpdated: (user) => {
                    setNotification({ message: 'User updated successfully', type: 'success' });
                },
                onUserDeleted: (userId) => {
                    setNotification({ message: 'User deleted successfully', type: 'success' });
                }
            }),
            showSubscriptionManagement && React.createElement(SubscriptionManagementModal, {
                onClose: () => setShowSubscriptionManagement(false),
                loggedInUser: loggedInUser,
                onSubscriptionUpdated: () => {
                    if (typeof window.refreshUsageStats === 'function') window.refreshUsageStats();
                    fetchTrialStatus();
                    setIsTrialBannerDismissed(false);
                    sessionStorage.removeItem('trial_banner_dismissed');
                }
            }),
            showTutorial && React.createElement(OnboardingTutorial, {
                steps: tutorialSteps,
                isAdmin: window.__IS_ADMIN__ || false,
                onComplete: handleTutorialComplete,
                onSkip: handleTutorialSkip
            }),
            React.createElement(Chatbot, { projectTasks: tasks, projectName: selectedProject })
        );
    };
</script>
