{% raw %}
<script type="text/babel">
    const GanttTab = ({ tasks }) => {
        const { useEffect, useRef } = React;
        const ganttContainerRef = useRef(null);

        useEffect(() => {
            if (!ganttContainerRef.current) return;

            // Initialize Gantt
            gantt.init(ganttContainerRef.current);

            // Configure Scale (Week Wise as requested)
            gantt.config.scales = [
                { unit: "year", step: 1, format: "%Y" },
                { unit: "month", step: 1, format: "%F" },
                { unit: "week", step: 1, format: "W%W" }
            ];
            gantt.config.scale_height = 75;
            gantt.config.min_column_width = 100;
            gantt.config.autoscroll = true;
            gantt.config.autoscroll_speed = 50;

            // Configure Date Format for Grid
            gantt.config.date_grid = "%d-%m-%Y";

            // Ensure proper row height for content visibility
            gantt.config.row_height = 35;
            gantt.config.task_height = 20;

            // Configure Columns with larger widths
            gantt.config.columns = [
                { name: "wbs", label: "WBS", width: 100, align: "center" },
                { name: "text", label: "Task Name", tree: true, width: 300 },
                { name: "start_date", label: "Start Date", align: "center", width: 150 },
                { name: "end_date", label: "End Date", align: "center", width: 150 },
                {
                    name: "progress", label: "%", align: "center", width: 80, template: function (obj) {
                        return Math.round((obj.progress || 0) * 100) + "%";
                    }
                }
            ];

            // Set grid width to ensure columns display properly
            gantt.config.grid_width = 800; 
            // Allow editing (optional, can be disabled if read-only)
            gantt.config.readonly = true;

            // Process tasks for DHTMLX
            const processTasks = (inputTasks) => {
                const data = [];
                const links = [];

                const traverse = (taskList, parentId = null) => {
                    if (!taskList) return;

                    taskList.forEach(task => {
                        // Parse dates carefully
                        let startDate = task.plannedStartDate ? new Date(task.plannedStartDate) : null;
                        let endDate = task.plannedEndDate ? new Date(task.plannedEndDate) : null;

                        // Validate dates
                        if (startDate && isNaN(startDate.getTime())) startDate = null;
                        if (endDate && isNaN(endDate.getTime())) endDate = null;

                        // Prevent negative duration / invalid ranges
                        // If we have both, ensure end >= start
                        if (startDate && endDate && endDate < startDate) {
                            endDate = new Date(startDate); // snap to start if invalid
                        }

                        // If DHTMLX receives Date objects, it ignores date_format config, which is safer here.
                        // Only add task if at least start date is valid (or we can fallback to today)
                        // For Gantt chart to render, it needs a valid date.

                        if (startDate) {
                            const dhtmlxTask = {
                                id: task.id,
                                text: task.taskName,
                                start_date: startDate,
                                parent: parentId ? parentId : 0,
                                open: false, // Initially collapsed
                                progress: (task.progress || 0) / 100,
                                wbs: task.wbs
                            };

                            if (endDate) {
                                dhtmlxTask.end_date = endDate;
                            } else {
                                // Default duration if no end date
                                dhtmlxTask.duration = 1;
                            }

                            // Explicit duration override if provided and valid
                            if (task.duration && task.duration > 0) {
                                dhtmlxTask.duration = task.duration;
                                // If we have duration, DHTMLX can calc end_date, so we can omit end_date if we want consistency
                                // But usually having both dates is fine if they match.
                            }

                            data.push(dhtmlxTask);
                        }

                        // Recursively process subtasks
                        if (task.subtasks && task.subtasks.length > 0) {
                            traverse(task.subtasks, task.id);
                        }
                    });
                };

                traverse(inputTasks);
                return { data, links };
            };

            const { data, links } = processTasks(tasks);

            // Clear and Parse
            gantt.clearAll();
            gantt.parse({ data, links });

            return () => {
                gantt.clearAll();
            };
        }, [tasks]);

        return (
            <div className="h-full flex flex-col">
                <div
                    ref={ganttContainerRef}
                    id="gantt_here"
                    className="flex-1 w-full bg-white rounded-xl shadow-lg overflow-hidden"
                    style={{ minHeight: '600px' }}
                ></div>
            </div>
        );
    };
</script>
{% endraw %}